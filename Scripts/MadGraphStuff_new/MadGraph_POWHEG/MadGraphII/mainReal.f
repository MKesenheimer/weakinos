      Program FKSterms

      implicit none

      include 'params.inc'

      call madgraph

      end


      Subroutine MADGRAPH()
!*************************************************************************
!     Main program for MadGraph
!*************************************************************************
      implicit none

! Constants

      include 'params.inc'


! Local Variables

      integer tops(0:4,0:maxnodes,0:maxtops)
      integer graphs(0:maxgraphs,0:maxlines) !graphs, topology internal lines
      integer next,i,ntopold,ii,j,idipol,i1
      double precision sflows(maxflows,maxflows)
      logical more, lpossible,foundborn,foundin,foundfi
      integer fortran,ascii_emitter,ascii_spectator,ascii_n,ascii_nr
      integer m,n,k,l,dum1,qcd_part
      integer notfound
      integer iline_copy(-maxlines:maxlines,maxdipoles)
      character*70 buff
      integer ipart(maxlines),step(maxlines),jhel,initc,dipcount
      character*2 mid
      character*3 number
      logical removedipole

! External Functions
      logical qmatch_check

! Global Variables

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup
      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      integer dipart(2*maxlines),dum,iline_orig(-maxlines:maxlines)
      common/to_dipart/dipart,dum,iline_orig

      character*25        name
      integer        iname
      common/to_name/iname,name
      integer alen(maxgraphs)
      integer wnum(-maxlines:maxlines),wcount,wlen(maxgraphs*maxlines)
      common/toopt/wcount,wnum,wlen,alen
      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      integer         graphcolor(0:2,0:maxflows,0:maxgraphs)
      common/to_color/graphcolor,flows
      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c

      logical          this_block(0:max_blocks), need_block(max_blocks)
      common/to_blocks/this_block              , need_block

      logical         sumgluons
      common/to_cflow/sumgluons

      logical              lwrite
      common/to_multiproc/ lwrite

      logical           jetloop
      common/to_jetloop/jetloop

      integer          matchline(0:maxlines)
      common/to_qmatch/matchline

      logical              cross_opt
      common /to_crossopt/ cross_opt

      character*70       cversion
      common/to_version/ cversion
      character*(40)       particleID, interactionID
      common/to_modelinput/particleID, interactionID

      logical             first_proc
      common/to_firstproc/first_proc

      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      integer dipollist(maxdipoles,2,2),nrdipols
      common /list/ dipollist,nrdipols

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer info_ijk(maxdipoles,2,5),nr,nrs,nrc,dipol
      logical offdiag
      common /ijk/ info_ijk,nr,nrs,nrc,offdiag
      common /dipolenumber/dipol

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

      integer wcount1(maxproc),acount1(maxproc)
      integer wlen1(maxgraphs*maxlines,maxproc)
      integer alen1(maxgraphs,maxproc),nproc1
      common/toglobal/wcount1,acount1,wlen1,alen1,nproc1

      integer isymn1
      common /isym/ isymn1

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

      character*(8) mass(max_particles)
      common /masses/ mass
! Data Table

! If you want the output function written using real*8 and complex*16
! style declarations, remove the comment character from the following
! line.

      data fortran /77/
      data interactionid /"???"/
      data particleid /"???"/
      
      character*140 buffer
      integer proc_number
      character*3 cpn
      common/ccpn/cpn

!-----------
! Begin Code
!-----------
c      open (unit=6, file='output.dat',status='unknown')
      cversion='Generated by MadGraph II'

      first_proc = .true.
      ntopold=0
c do not write extra files, only the dipol1234.f:
      lwrite=.false.
      jetloop=.false.
      call resetV
      call Load_Particles
      call Load_Interactions
      print*,' '
c      call writelogo
      print*,' '

      proc_number=0
      open (unit=62,file='proc_number_real',status='unknown')
      read(62,*,err=32,end=32) proc_number
      proc_number=proc_number+1
      rewind(62)
 32   continue
      write(62,*) proc_number
      close(62)
         
      call readproc(more)
 10   continue

      if(proc_number.le.9) then
         cpn=char(48)//char(48)//char(proc_number+48)
      elseif(proc_number.le.99) then
         cpn=char(48)//char(proc_number/10+48)
     &        //char(mod(proc_number,10)+48) 
      elseif(proc_number.le.999) then
         cpn=char(proc_number/100+48)
     &        //char((proc_number-(proc_number/100)*100)/10+48)
     &        //char(mod(proc_number-(proc_number/100)*100,10)+48)
      endif

      do i=1,iline(0)
       mass(i)=str(2,iline(i))
      enddo


c calculating the symmetry factor of the n+1 process
      do i=1,maxlines
       ipart(i)=i
      enddo
      call getdenom(isymn1,initc,jhel,step,ipart)

c copy the process to to iline_orig
      do k=-maxlines,maxlines
       iline_orig(k)=iline(k)
      enddo


      notfound=0
      nproc1=0
      graphnr=0
c     initialize flowinfo
      do l=1,max_particles
         flowinfo(l,1)=0
         flowinfo(l,2)=0
      enddo
      call getflowinfo1()
c$$$         open(unit=isubfile,file='subproc.txt',status='unknown')
c$$$         write(isubfile,'(a$)') 'PROCESS = '
      open(unit=22,status='unknown')
      open(unit=25,status='unknown')
      open(unit=26,status='unknown')

      iname=12
      name='realmtrx_'//cpn

      open(unit=91,status='unknown') ! here are the calls to HELAS temporarly stored
      flows(0,0,0,0)=0
      sumgluons=.true.
      sumgluons=.false.
      wcount=0
      print*,' '
      next=iline(0)
      open (unit=58,status='unknown')
      open (unit=34,status='unknown')
      open (unit=35,status='unknown')
      open (unit=36,status='unknown')
      open (unit=59,status='unknown')
      open (unit=37,status='unknown')

      call InsertFields(tops,graphs)
      call write_config(tops,-99) !Close out 35
      close(34,status='delete')
      close(35,status='delete')
      close(36,status='delete')
      close(59,status='delete')
      close(37,status='delete')
 215  continue
c         print*,'here grpahs',graphs(0,0)
      if (graphs(0,0) .eq. 0) then
         print*, 'No graphs for this process', (iline(i),i=1,iline(0))
c         print*, 'No dipols found for this configuraton', (iline(i),i=1,iline(0))
         notfound=notfound+1
         close(58,status='delete')
      else
         print*,'There are ',graphs(0,0),' graphs.'
         graphcolor(0,0,0)=graphs(0,0) !Number of graphs
         print*,' '
         call saveproc(i,graphs(0,0))
            
c Set i=1, because otherwise we do not get all dipolXX.f files.
         i=1

c Do write the dipolXX.f files:
         lwrite=.true.
         if (i .gt. 0 .or. i .lt. -1) then !New Process 
            if (lwrite) then    !(i<0  means found matched process abs(i))
               lwrite=.false.
               first_proc = .false. !Now have processes
               call write_symmetry
               call square(flows,sflows)
c$$$c Write postscripts of the diagrams
c$$$                  call gen_ps(graphs,tops,iline(0))
               open(unit=99,status='unknown') ! Here is the color info temporarly stored
               call matrixcolor(graphcolor,sflows)
               rewind 99        ! Rewind color info before writing in writeamp
               rewind 91        ! Rewind HELAS info before writing in writeamp
               call writeamp(graphs(0,0),next,
     $              goal_coup(2),goal_coup(1),i,flows)
               close(99,status='delete')

               open(unit=itnum,file='leshouches_R_'//
     &              cpn//'.inc',status='unknown')
               call write_leshouche(flows, itnum, i) !(color,ilun,iproc)
               close(itnum)
               do j=0,iline(0)
                  matchline(j)=iline(j)
               enddo
            endif
         endif
         close(91,status='delete')
         close(58,status='delete')
         dipol = dipol+1
      endif
      close(35)
      write(*,*) 
      write(*,*) 

c Write auto_dsig.f
      rewind 22
c$$$      call writedsig(iline(0),22,.false.)
      close(22,status='delete')
      close(25,status='delete')
      close(26,status='delete')

      if (notfound.eq.0) then
         open (unit=62,file='proc_label_real',
     &        status='old',access='append')
         write (buffer,'(2i5,2i10)')proc_number,iline(0),
     &        info_p(5,inverse(iline(1))),info_p(5,inverse(iline(2)))
         write (buffer(31:140),*) (info_p(5,iline(i)),i=3,iline(0))
         write (62,*) buffer
         close(62)
         open (unit=62,file='proc_number_real',status='old')
         read(62,*) proc_number
         proc_number=proc_number+1
         rewind(62)
         write(62,*) proc_number
         close(62)
      endif

c continue with the loop over multi-particles         
      call readproc(more)
      if (more) goto 10

      write(*,*)
      write(*,*)
      write(*,*) 'Thank you for using MadGraph'
      write(*,*)
      open (unit=62,file='proc_number_real',status='old')
      read(62,*) proc_number
      proc_number=proc_number-1
      rewind(62)
      write(62,*) proc_number
      close(62)
      
      return
      end










      subroutine square(flows,sflows)
!**************************************************************************
!     Square terms and simplify to get color factors for flows
!**************************************************************************
      implicit none

! Constants

      include 'params.inc'
c      integer    maxlines,  maxfactors,  maxterms,    maxflows
c      parameter (maxlines=8,maxfactors=9,maxterms=250,maxflows=200)

! Arguments

      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      double precision  sflows(maxflows,maxflows)

! Local Variables

      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer nflows,nfactors,nelements
      integer iflow,ifact,ielement,iterm,cterm,fterm
      integer cflow,cfact,cfactors
      integer i,j
      double precision sdiag
      
! Global Variables

      integer           isflows(2,maxflows,maxflows)
      common/to_isflow/isflows
      logical         sumgluons
      common/to_cflow/sumgluons
!-----------
! Begin Code
!-----------
      nflows=flows(0,0,0,0)
      sumgluons=.true.
      do iflow=1,nflows
c         write(*,*) 'Flow number ',iflow
c         call PrintColors(flows(0,0,0,iflow))
         call SimpColors(flows(0,0,0,iflow),-1)  !Sum over internal gluon
c         call PrintColors(flows(0,0,0,iflow))
      enddo
      do iflow=1,nflows
         do cflow=iflow,nflows
            do iterm=1,flows(0,0,0,iflow)
               nfactors=flows(0,0,iterm,iflow)
               do ifact=0,nfactors
                  nelements=abs(flows(0,ifact,iterm,iflow))
                  do ielement=0,nelements
                     color(ielement,ifact,iterm)=
     &                    flows(ielement,ifact,iterm,iflow)
                  enddo
               enddo
            enddo                    !have all terms copied
            color(0,0,0)=flows(0,0,0,iflow)    !This is number of terms
            do cterm=2,flows(0,0,0,cflow)
               do iterm=1,flows(0,0,0,iflow)
                  call copyterm(color,iterm,-999,-999)
               enddo
            enddo              !now we have enough set for all square terms
            do cterm=1,flows(0,0,0,cflow)
               cfactors=flows(0,0,cterm,cflow)
               do iterm=1,flows(0,0,0,iflow)
                  nfactors=flows(0,0,iterm,iflow)
                  fterm = flows(0,0,0,iflow)*(cterm-1)+iterm
                  color(0,0,fterm) = nfactors+cfactors-1
                  color(0,1,fterm) = 2 !num and denom
                  color(1,1,fterm) = color(1,1,fterm)*
     &                 flows(1,1,cterm,cflow)
                  color(2,1,fterm) = color(2,1,fterm)*
     &                 flows(2,1,cterm,cflow)
                  do cfact=2,cfactors
                     nelements=abs(flows(0,cfact,cterm,cflow))
                     color(0,nfactors+cfact-1,fterm)=
     &                    flows(0,cfact,cterm,cflow)
                     if (flows(0,cfact,cterm,cflow) .lt. 0) then !T Matrix
                        color(1,cfact+nfactors-1,fterm) =
     &                       flows(2,cfact,cterm,cflow)
                        color(2,cfact+nfactors-1,fterm) =
     &                          flows(1,cfact,cterm,cflow)
                        do ielement=3,nelements
                           color(ielement,cfact+nfactors-1,fterm)=
     &                          flows(nelements-ielement+3,cfact,
     &                          cterm,cflow)
                        enddo
                     else
                        do ielement=1,nelements
                           color(ielement,cfact+nfactors-1,fterm)=
     &                          flows(nelements-ielement+1,cfact,
     &                          cterm,cflow)
                        enddo
                     endif
                  enddo
               enddo
            enddo
            call simpcolors(color,1)
            call addterms(color)
            if (color(0,0,0) .ge. 1) then
               isflows(1,iflow,cflow)=color(1,1,1)
               isflows(2,iflow,cflow)=color(2,1,1)
               isflows(1,cflow,iflow)=color(1,1,1)
               isflows(2,cflow,iflow)=color(2,1,1)
               sflows(iflow,cflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               sflows(cflow,iflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               if (color(0,0,0) .gt. 1) then
                  print*,'Error More than one term',color(0,0,1)
                  call printcolors(color)
               elseif (color(0,0,1) .gt. 1) then !one factor
                  print*,'One term but many factors',color(0,0,1),
     &                 iflow,cflow,color(1,1,1)
                  call printcolors(color)
               endif
            else
               sflows(iflow,cflow)=0.d0
               sflows(cflow,iflow)=0.d0
            endif
         enddo
      enddo
      end





      Subroutine storecolor(color,iflow)
!**********************************************
! Stores color information of color(...) in larger
! color matrix color_tot(2,1000,0:2maxlines,0:maxterms)
!**********************************************

      implicit none

      include 'params.inc'

c    Arguments
      integer color(0:2*maxlines,0:maxfactors,0:maxterms),iflow

c    Local
      integer ifactor,nterms,iterm,i

c    Global
      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),
     .        maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      if(iflow .gt.graphnr) then
      graphnr=graphnr+1
      nterms=color(0,0,0)
      color_tot(1,graphnr,0,0,0)=color(0,0,0)

      do iterm=1,nterms
      max_ifactor(iterm)=color(0,0,iterm)
      color_tot(1,graphnr,1,1,iterm)=color(1,1,iterm)
      color_tot(1,graphnr,2,1,iterm)=color(2,1,iterm)

      do ifactor=0,max_ifactor(iterm)
       color_tot(1,graphnr,0,ifactor,iterm)=color(0,ifactor,iterm)
       color_tot(1,graphnr,1,ifactor,iterm)=color(1,ifactor,iterm)
       color_tot(1,graphnr,2,ifactor,iterm)=color(2,ifactor,iterm)
        if(abs(color(0,ifactor,iterm)) .gt.2) then
          do i=3,abs(color(0,ifactor,iterm))
            color_tot(1,graphnr,i,ifactor,iterm)=color(i,ifactor,iterm)
          enddo
        endif
      enddo
      enddo
      endif

      end


      Subroutine getflowinfo1()
!**********************************************
! Provides information whether the external particles
! are particles/antiparticles and in-/outgoing
!**********************************************

      implicit none
      include 'params.inc'

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup

c  Global
      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo
      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      integer dipart(2*maxlines),dum,iline_orig(-maxlines:maxlines)
      common/to_dipart/dipart,dum,iline_orig

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

c  Local
      integer i,l

      do i=1,iline(0)
         flowinfo(i,1)=0
         flowinfo(i,2)=0
      enddo

      do i=1,iline(0)
         if (info_p(1,iline(i)).gt.1) then ! colored particle
            if ( info_p(5,iline(i)).gt.0 .and.
     &           info_p(1,iline(i)).eq.3) then ! particle (triplet)
               if (i.le.nincoming) then
c     1. initial anti-quark
                  flowinfo(i,1)=0
                  flowinfo(i,2)=-1
               else
c     2. final quark
                  flowinfo(i,1)=1
                  flowinfo(i,2)=1
               endif

            elseif ( info_p(5,iline(i)).lt.0 .and.
     &               info_p(1,iline(i)).eq.3) then ! anti-particle (triplet)
               if (i.le.nincoming) then
c     3. initial quark
                  flowinfo(i,1)=0
                  flowinfo(i,2)=1
               else
c     4. final anti-quark
                  flowinfo(i,1)=1
                  flowinfo(i,2)=-1
               endif
            elseif(info_p(1,iline(i)).eq.8) then
c     5. gluon
               flowinfo(i,1)=0
               flowinfo(i,2)=0
            else
               write (*,*) 'ERROR #125',iline(i),info_p(1,iline(i))
               stop
            endif
         endif
      enddo

      return
      end
