!-----------------------
! madgraph - a Feynman Diagram package by Tim Stelzer and Bill Long 
! (c) 1993
!
! Filename: writedsig.f
!-----------------------
      subroutine writedsig(NLINES,lun,madweight)
c***********************************************************************
c     Routine to write subroutine dsig.f
c***********************************************************************
      implicit none
c
c     Constants
c
      integer    ln
      parameter (ln=29)
c
c     Arguments
c
      integer nlines,lun
      logical madweight
c
c     Local
c
      character*70 buff
c
c     Global
c
      integer        ndsig,nproc,nperm
      common/to_dsig/ndsig,nproc,nperm
      integer        tcount
      common/to_wgt/ tcount

      logical         lwp,lwm,lz,decay,cross
      common/to_decay/lwp,lwm,lz,decay,cross

      character*70       cversion
      common/to_version/ cversion

      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      logical DipolSub
      data DipolSub/.true./

      logical DipolSubQED
      data DipolSubQED/.false./
      
      logical firsttime
      data firsttime/.true./
      save firsttime

c-----
c Begin Code
c-----
      if (madweight) then
        open(unit=ln,file='auto_dsig_MW.f',status='unknown')
      else
        open(unit=ln,file='auto_dsig.f',status='unknown')
      endif

      if(.not.DipolSub) then ! For dipolsub we read the existing auto_dsig.f

      write(ln,10) 'DOUBLE PRECISION FUNCTION DSIG(PP,WGT)'
! write comments

      write(ln,5) '****************************************************'
c      write(ln,5) '    FUNCTION GENERATED BY ' // cversion
      write(ln,5) cversion
      write(ln,5) '    RETURNS DIFFERENTIAL CROSS SECTION'
      write(ln,5) '    Input:'
      write(ln,5) '            pp    4 momentum of external particles'
      write(ln,5) '            wgt   weight from Monte Carlo'
      write(ln,5) '    Output:'
      write(ln,5) '            Amplitude squared and summed'
      write(ln,5) '****************************************************'

      write(ln,10) 'IMPLICIT NONE'

! write parameters

      write(ln,5)  ' '
      write(ln,5)  'CONSTANTS'
      write(ln,5)  ' '
      write(ln,10) 'include "genps.inc"'
      write(ln,10) 'include "nexternal.inc"'
      write(ln,10) 'DOUBLE PRECISION       CONV'
      if (MadWeight) then
      write(ln,10) 'PARAMETER (CONV=1d0)  !CONV TO GeV-n !!'
      else
      write(ln,10) 'PARAMETER (CONV=389379.66*1000)  !CONV TO PICOBARNS'
      endif
      write(ln,10) 'REAL*8     PI'
      write(ln,10) 'PARAMETER (PI=3.1415926d0)'
! write argument declarations

      write(ln,5) ' '
      write(ln,5) 'ARGUMENTS '
      write(ln,5) ' '

      write(ln,10) 'DOUBLE PRECISION PP(0:3,NEXTERNAL), WGT'

! write local declarations

      write(ln,5) ' '
      write(ln,5) 'LOCAL VARIABLES '
      write(ln,5) ' '
      write(ln,10) 'INTEGER I, ICROSS,ITYPE,LP'
      write(ln,10) 'DOUBLE PRECISION P1(0:3,NEXTERNAL)'
      write(ln,10) 'DOUBLE PRECISION u1,ub1,d1,db1,c1,cb1,s1,sb1,b1,bb1'
      write(ln,10) 'DOUBLE PRECISION u2,ub2,d2,db2,c2,cb2,s2,sb2,b2,bb2'
      write(ln,10) 'DOUBLE PRECISION g1,g2'
      write(ln,10) 'DOUBLE PRECISION a1,a2'
      write(ln,10) 'DOUBLE PRECISION XPQ(-7:7)'
      if (MadWeight) then
      write(ln,10) 'DOUBLE PRECISION DSIGUU,TWGT'
      else
      write(ln,10) 'DOUBLE PRECISION DSIGUU'
      endif
      write(ln,5) ' '
      write(ln,5) 'EXTERNAL FUNCTIONS'
      write(ln,5) ' '
      write(ln,10) 'LOGICAL PASSCUTS'
c      if (MadWeight) then
c         write(ln,10) 'DOUBLE PRECISION ALPHAS2,PDG2PDF'
c      else
         write(ln,10) 'DOUBLE PRECISION ALPHAS2,REWGT,PDG2PDF'
c      endif
      write(ln,5) ' '
      write(ln,5) 'GLOBAL VARIABLES'
      write(ln,5) ' '


      write(ln,10) 'INTEGER              IPROC'
      write(ln,10) 'DOUBLE PRECISION PD(0:MAXPROC)'
      write(ln,10) 'COMMON /SubProc/ PD, IPROC'
      write(ln,10) 'include "coupl.inc"'
      write(ln,10) 'include "run.inc"'
      write(ln,5) ' '
      write(ln,5) 'DATA'
      write(ln,5) ' '
      write(ln,10) 'DATA u1,ub1,d1,db1,c1,cb1,s1,sb1,b1,bb1/10*1d0/'
      write(ln,10) 'DATA u2,ub2,d2,db2,c2,cb2,s2,sb2,b2,bb2/10*1d0/'
      write(ln,10) 'DATA a1,g1/2*1d0/'
      write(ln,10) 'DATA a2,g2/2*1d0/'
      write(ln,10) 'DATA IPROC,ICROSS/1,1/'
      write(ln,5) '----------'
      write(ln,5) 'BEGIN CODE'
      write(ln,5) '----------'
      write(ln,10) 'DSIG = 0D0'
      write(ln,10) 'IF (PASSCUTS(PP)) THEN'
      if(nincfirst.eq.2)then
      WRITE(LN,15) 'IF (ABS(LPP(1)) .GE. 1) THEN'
      write(ln,20) 'LP=SIGN(1,LPP(1))'
C  JA: Write only the relevant PDF calls to save time
      do while (.true.)
         read(25,'(a)',end=996) buff
         write(ln,20) buff
      enddo
 996  rewind(25)
      write(ln,15) 'ENDIF'
      WRITE(LN,15) 'IF (ABS(LPP(2)) .GE. 1) THEN'
      write(ln,20) 'LP=SIGN(1,LPP(2))'
C  JA: Write only the relevant PDF calls to save time
      do while (.true.)
         read(26,'(a)',end=997) buff
         write(ln,20) buff
      enddo
 997  rewind(26)
      write(ln,15) 'ENDIF'
      endif
      write(ln,15) 'PD(0) = 0d0'
      write(ln,15) 'IPROC = 0'
      do while (.true.)
         read(lun,'(a)',end=998) buff
         write(ln,10) buff(4:)
         read(lun,'(a)',end=998) buff
         write(ln,10) buff(4:)
         read(lun,'(a)',end=998) buff
      enddo
 998  rewind(lun)
      do while (.true.) 
         read(lun,'(a)',end=999) buff
c         write(*,*) buff(1:60)
         if (index(buff,"CALL") .gt. 0) write(ln,15) buff
      enddo
 999  write(ln,15) 'dsiguu=dsiguu*rewgt(PP)'
      write(ln,15) 'If (dsiguu .lt. 1d199) then'
      if(nincfirst.eq.2) then
         write(ln,15) '    dsig = pd(IPROC) * conv * dsiguu'
      else ! Decay, no conversion to pb needed
         write(ln,15) '    dsig = pd(IPROC) * dsiguu'
      endif
      write(ln,15) 'else'
      write(ln,15) '    write(*,*) "Error in matrix element"'
      write(ln,15) '    dsiguu=0d0'
      write(ln,15) '    dsig = 0d0'
      write(ln,15) 'endif'
      if(nincfirst.eq.2) then
        if (.not.MadWeight) then
          write(ln,15) 'call unwgt(pp,pd(iproc)*conv*dsiguu*wgt)'
        else
          write(ln,15) 'call transfer_fct(PP(0,1),TWGT)'
          write(ln,15)  'if (twgt .lt. 10d0 .and. twgt .ge. 0d0) then'
          write(ln,15) '  dsig=dsig*twgt'
          write(ln,15) 'else'
      write(ln,15) 'write(*,*) "Error in transfer function twgt=",twgt'
          write(ln,15) '    dsig = 0d0'
          write(ln,15)  'endif'
      endif
      else ! Decay, no conversion to pb needed
         write(ln,15) 'call unwgt(pp,pd(iproc)*dsiguu*wgt)'
      endif
      write(ln,10) 'ENDIF'
      write(ln,10) 'END'



c Read the existing auto_dsig.f for the dipoles
c and add a few extra lines to call the dipolesum and subtract them
      elseif ((DipolSub.and.firsttime).or.(DipolSubQED.and.firsttime))then
         open(unit=32,status='unknown')
         do while (.true.)
            read(ln,'(a)',end=987) buff
            write(32,'(a)') buff
            if(index(buff,'DOUBLE PRECISION rwgt').gt.0)then
               write(32,10) 'DOUBLE PRECISION SUBTRACT, SUBTRACT2'
            endif
            if(index(buff,'CALL SMATRIX').gt.0)then
               write(32,15) ' CALL DIPOLSUM(PP,SUBTRACT)'
               write(32,5)  '    CALL DIPOLSUMFINITE(PP,SUBTRACT2)'
               write(32,5)  '    SUBTRACT=SUBTRACT+SUBTRACT2'
               write(32,15) ' DSIGUU=DSIGUU-SUBTRACT'
            endif
         enddo
 987     close(ln,status='delete')
         rewind(32)
         open(unit=ln,file='auto_dsig.f',status='unknown')
         do while (.true.)
            read(32,'(a)',end=986) buff
            write(ln,'(a)') buff
         enddo
 986     close(32,status='delete')
         firsttime=.false.

      endif !DipolSub

      close(ln)
 5    format('C ',A)
 10   format(6X,A)
 15   format(9X,A)
 20   format(12X,A)
 21   format(5x,'&',9x,A)
      end

      subroutine genparton(ncross,ipart,fname,nproc,imatch)
c*************************************************************************
c     Writes out calls for the parton distributions which must be folded
c     with the different cross sections
c*************************************************************************
      implicit none
      
! Constants

      include 'params.inc'

! Arguments

      integer ncross,ipart(maxlines,maxcross),nproc,imatch(0:maxcross)
      character*(*) fname

! Local
      integer i,j,nlen(7),lun
      integer ib,ic,nb,nch,nl,ig,ng,nq,nfound
      integer ichar,jchar,ipdg,lunpdf(2)
      character*5 ch(7)
      character*6 buff
      character*20 cname
      character*2 cinit

! Global Variables

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup

      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c
      integer        nsubproc,nproc1,nperm
      common/to_dsig/nsubproc,nproc1,nperm
      logical         lwp,lwm,lz,decay,cross
      common/to_decay/lwp,lwm,lz,decay,cross
      integer        tcount
      common/to_wgt/ tcount

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      data nperm,nproc1/-1,-1/
      data tcount/0/
!-----
! Begin Code
!-----
      lun = 22
      nsubproc = 22
      nproc1=max(nproc,nproc1)
      do i=1,ncross
         tcount=tcount+1
c         write(71,'($2i6,2x)') tcount,nproc

C
C   JA: Write calls for each parton species to save time
C
         lunpdf(1)=25
         lunpdf(2)=26
         do j=1,nincfirst
           call part_string(inverse(iline(j)),ch(j),nlen(j))
           ipdg=index('gduscbad~u~s~c~b~',ch(j)(1:nlen(j)))
           if (ipdg .ne. 0) then
             ch(j)(2:2)='b'   
             if(ipdg.le.6)then
               ipdg=ipdg-1
             else if(ipdg.gt.7)then
               ipdg=ipdg-6
               ipdg=ipdg/2
               ipdg=-ipdg
             endif
             write( ch(j)(nlen(j)+1:nlen(j)+1),'(i1)') j
             write(lunpdf(j),11) ch(j)(1:nlen(j)+1),j,ipdg,j,j
 11          format(a3,'= PDG2PDF(ABS(LPP(',i1,')),',i2,'*LP,XBK(',i1,
     $          '),DSQRT(Q2FACT(',i1,')))')
           endif
         enddo


         do j=1,nincfirst
            call part_string(inverse(iline(ipart(j,i))),ch(j),nlen(j))
c            write(71,'($a4)') ch(j)
c
c     Only write pdf call for gluons or quarks. Leptons use 1d0
c
            if (index('agudcsbu~d~c~s~b~',ch(j)(1:nlen(j))) .eq. 0) then
               ch(j)='1d0'
               nlen(j)=3
            else
               ch(j)(2:2)='b'   
               write( ch(j)(nlen(j)+1:nlen(j)+1),'(i1)') j
            endif
         enddo

c         write(71,'($a4)') ' -> '
         nl=0
         nch=0
         nb=0
         cname=' !'
         ichar=3
         do j=3,iline(0)
            call part_string(iline(ipart(j,i)),cname(ichar:ichar+2),
     &           jchar)
c$$$            write(71,'(a4$)') cname(ichar:ichar+2)
            ichar=ichar+jchar
            nl=nl+1
         enddo
         write(lun,'(6x,2a)') 'IPROC=IPROC+1      !',proc(2:iproc)
c         write(71,*) ' '
c         write(lun,'(a,i3,a,i2,4a)') '      IF (IPROC .EQ.',abs(nproc),
c     $        ' .AND. ICROSS .EQ. ',i,') PD = PD + ',ch(1)(1:nlen(1)+1),
c     $        ' * ',ch(2)(1:nlen(2)+1)

         if(nincfirst.eq.2) then
            write(lun,'(6x,4a)') 'PD(IPROC)=PD(IPROC-1) + ',
     &           ch(1)(1:nlen(1)+1),' * ',ch(2)(1:nlen(2)+1)
         else
            write(lun,'(6x,4a)') 'PD(IPROC)=PD(IPROC-1) + 1d0'
         endif
      if (nproc .ne. 0 .and. i .eq. 1) then
c         write(lun,10) 'IF (IPROC .EQ. ',nproc,') CALL ',
c     $        fname(1:len(fname)-8),'(PP,DSIGUU,ICROSS)'
         write(lun,*) 'CALL ',fname(1:len(fname)-8),'(PP,DSIGUU)'
      else
         write(lun,*) ' '
      endif



c
c     Below is for keeping track of heavy quark flavors
c
c         write(buff,'(a1,i1,a1,i1)') 'C',nch,'B',nb
c         write(lun,23) '   DSIG1(',buff(1:6),') = DSIG1(',buff(1:6),
c     $       ') + ANS(',imatch(i),',IPROC) * ',ch(1)(1:nlen(1)+1),' * ',
c     $       ch(2)(1:nlen(2)+1),cname(1:ichar)

c
c     This if for determing the number of quarks vs gluons in process.
c
c         write(buff,'(a2,i1,a1,i1,2x)') 'NG',ng
c         write(lun,22) '   DSIG1(',buff(1:6),') = DSIG1(',buff(1:6),
c     $       ') + ANS(',imatch(i),',IPROC) * ',ch(1)(1:nlen(1)+1),' * ',
c     $        ch(2)(1:nlen(2)+1)

c
c     This if for determing the initial state configuration ie gg,qg,gq,gg
c
c         write(buff,'(a2,4x)') cinit
c         write(lun,22) '   DSIG1(',buff(1:6),') = DSIG1(',buff(1:6),
c     $       ') + ANS(',imatch(i),',IPROC) * ',ch(1)(1:nlen(1)+1),' * ',
c     $        ch(2)(1:nlen(2)+1)

c
c     This is for determining the exact parton configuration
c
c         write(lun,24) '   FRACT(',tcount,
c     &        ') = ans(',imatch(i),',IPROC) * ',ch(1)(1:nlen(1)+1),' * '
c     $        ,ch(2)(1:nlen(2)+1)

 22      format(5a,i2,a,a3,a,a3)
 23      format(5a,i2,a,a3,a,a3,a)
 24      format(a,i6,a,i2,a,a,a3,a)
c         write(lun,20) 'DSIG = DSIG + ',ch
c         write(lun,20) 'DSIG = DSIG + ',ch(1)(1:nlen(1)+1),' * ',
c     &        ch(2)(1:nlen(2)+1),' * ','ANS(',i,' ,IPROC)',
c     &        ' * L',nl,' * C',nch,' * B',nb
      enddo
c      write(lun,'(a)') 'ENDIF'
c      write(lun,*)
c$$$      write(71,*)
 10   format( a,i4,3a)
 25   format( a,a3,a3,a3,a3,a4,i3,a,i3,a1,a,i1,a,i1,a,i1)
 20   format( a,3a3,2a,i3,a,a,i1,a,i1,a,i1)
      end

      subroutine genparton2()
c*************************************************************************
c     Writes out calls for the parton distributions which must be folded
c     with the different cross sections
c
c     Be careful if you change something here, you might also need to
c     change it up above in genparton()
c
c*************************************************************************
      implicit none
      
! Constants

      include 'params.inc'

! Arguments

c      integer ncross,ipart(maxlines,maxcross),nproc,imatch(0:maxcross)
c      character*(*) fname

! Local
      integer i,j,nlen(7),lun
      integer ichar,jchar,ipdg,lunpdf(2)
      character*5 ch(7)
      character*6 buff
      character*20 cname
      character*2 cinit
      integer ncross,nproc

! Global Variables

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup

      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

!-----
! Begin Code
!-----
      lun = 22
c      nsubproc = 22
      ncross = 1
      nproc  = 1

c      write(*,*) 'Generating parton 2',(iline(j),j=1,iline(0))

C
C   JA: Write calls for each parton species to save time
C
      lunpdf(1)=25
      lunpdf(2)=26
      do j=1,nincfirst
         call part_string(inverse(iline(j)),ch(j),nlen(j))
         ipdg=index('gduscbad~u~s~c~b~',ch(j)(1:nlen(j)))
         if (ipdg .ne. 0) then
            ch(j)(2:2)='b'   
            if(ipdg.le.6)then
              ipdg=ipdg-1
            else if(ipdg.gt.7)then
              ipdg=ipdg-6
              ipdg=ipdg/2
              ipdg=-ipdg
            endif
            write( ch(j)(nlen(j)+1:nlen(j)+1),'(i1)') j
            write(lunpdf(j),11) ch(j)(1:nlen(j)+1),j,ipdg,j,j
 11         format(a3,'= PDG2PDF(ABS(LPP(',i1,')),',i2,'*LP,XBK(',i1,
     $         '),DSQRT(Q2FACT(',i1,')))')
         endif
      enddo


      do j=1,nincfirst
         call part_string(inverse(iline(j)),ch(j),nlen(j))
c            write(71,'($a4)') ch(j)
c
c     Only write pdf call for gluons or quarks. Leptons use 1d0
c
         if (index('agudcsbu~d~c~s~b~',ch(j)(1:nlen(j))) .eq. 0) then
            ch(j)='1d0'
            nlen(j)=2
         else
            ch(j)(2:2)='b'   
            write( ch(j)(nlen(j)+1:nlen(j)+1),'(i1)') j
         endif
      enddo
c      if (index('gudcsbu~d~c~s~b~',ch(j)(1:nlen(j))) .ne. 0) then
c         ch(1)(nlen(1)+1:nlen(1)+1)='1'
c         ch(2)(nlen(2)+1:nlen(2)+1)='2'
c      endif

c      cname=' !'
c      ichar=3
c      do j=3,iline(0)
c         call part_string(iline(j),cname(ichar:ichar+2),
c     &        jchar)
c         write(71,'($a4)') cname(ichar:ichar+2)
c         ichar=ichar+jchar
c      enddo
c      write(71,*) ' '
      write(lun,'(6x,2a)') 'IPROC=IPROC+1      !',proc(2:iproc)

      if(nincfirst.eq.2) then
         write(lun,'(6x,4a)') 'PD(IPROC)=PD(IPROC-1) + ',
     &        ch(1)(1:nlen(1)+1),' * ',ch(2)(1:nlen(2)+1)
      else
         write(lun,'(6x,4a)') 'PD(IPROC)=PD(IPROC-1) + 1d0'
      endif

c      write(lun,'(a,i3,a,i2,4a)') '      IF (IPROC .EQ.',abs(nproc),
c     $        ' .AND. ICROSS .EQ. ',1,') PD = PD + ',ch(1)(1:nlen(1)+1),
c     $     ' * ',ch(2)(1:nlen(2)+1)

      write(lun,*) ' '

 22      format(5a,i2,a,a3,a,a3)
 23      format(5a,i2,a,a3,a,a3,a)
 24      format(a,i6,a,i2,a,a,a3,a)
      write(71,*)
 10   format( a,i4,3a)
 25   format( a,a3,a3,a3,a3,a4,i3,a,i3,a1,a,i1,a,i1,a,i1)
 20   format( a,3a3,2a,i3,a,a,i1,a,i1,a,i1)
      end









