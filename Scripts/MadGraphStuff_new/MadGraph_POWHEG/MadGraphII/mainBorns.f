      Program FKSterms

      implicit none

      include 'params.inc'

      call madgraph

      end






      Subroutine MADGRAPH()
!*************************************************************************
!     Main program for MadGraph
!*************************************************************************
      implicit none

! Constants

      include 'params.inc'


! Local Variables

      integer tops(0:4,0:maxnodes,0:maxtops)
      integer graphs(0:maxgraphs,0:maxlines) !graphs, topology internal lines
      integer next,i,ntopold,ii,j,idipol,i1
      double precision sflows(maxflows,maxflows)
      logical more, lpossible,foundborn,foundin,foundfi
      integer fortran,ascii_emitter,ascii_spectator,ascii_n,ascii_nr
      integer m,n,k,l,dum1,qcd_part
      integer notfound
      integer iline_copy(-maxlines:maxlines,maxdipoles)
      character*70 buff
      integer ipart(maxlines),step(maxlines),jhel,initc,dipcount
      character*2 mid
      character*3 number
      logical removedipole

! External Functions
      logical qmatch_check

! Global Variables

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup
      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      integer dipart(2*maxlines),dum,iline_orig(-maxlines:maxlines)
      common/to_dipart/dipart,dum,iline_orig

      character*25        name
      integer        iname
      common/to_name/iname,name
      integer alen(maxgraphs)
      integer wnum(-maxlines:maxlines),wcount,wlen(maxgraphs*maxlines)
      common/toopt/wcount,wnum,wlen,alen
      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      integer         graphcolor(0:2,0:maxflows,0:maxgraphs)
      common/to_color/graphcolor,flows
      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c

      logical          this_block(0:max_blocks), need_block(max_blocks)
      common/to_blocks/this_block              , need_block

      logical         sumgluons
      common/to_cflow/sumgluons

      logical              lwrite
      common/to_multiproc/ lwrite

      logical           jetloop
      common/to_jetloop/jetloop

      integer          matchline(0:maxlines)
      common/to_qmatch/matchline

      logical              cross_opt
      common /to_crossopt/ cross_opt

      character*70       cversion
      common/to_version/ cversion
      character*(40)       particleID, interactionID
      common/to_modelinput/particleID, interactionID

      logical             first_proc
      common/to_firstproc/first_proc

      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      integer dipollist(maxdipoles,2,2),nrdipols
      common /list/ dipollist,nrdipols

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer info_ijk(maxdipoles,2,5),nr,nrs,nrc,dipol
      logical offdiag
      common /ijk/ info_ijk,nr,nrs,nrc,offdiag
      common /dipolenumber/dipol

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

      integer wcount1(maxproc),acount1(maxproc)
      integer wlen1(maxgraphs*maxlines,maxproc)
      integer alen1(maxgraphs,maxproc),nproc1
      common/toglobal/wcount1,acount1,wlen1,alen1,nproc1

      integer isymn1
      common /isym/ isymn1

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

      character*(8) mass(max_particles)
      common /masses/ mass
! Data Table

! If you want the output function written using real*8 and complex*16
! style declarations, remove the comment character from the following
! line.

      data fortran /77/
      data interactionid /"???"/
      data particleid /"???"/
      
      character*140 buffer
      integer proc_number
      character*3 cpn
      common/ccpn/cpn

!-----------
! Begin Code
!-----------
c      open (unit=6, file='output.dat',status='unknown')
      cversion='Generated by MadGraph II'

      first_proc = .true.
      ntopold=0
c do not write extra files, only the dipol1234.f:
      lwrite=.false.
      jetloop=.false.
      call resetV
      call Load_Particles
      call Load_Interactions
     
c get the gluon internal number
      call getparticle('g',dipart,dum)

      print*,' '
c      call writelogo
      print*,' '

      open (unit=62,file='proc_number',status='old')
      read(62,*,err=32,end=32) proc_number
      proc_number=proc_number+1
      rewind(62)
 32   continue
      write(62,*) proc_number
      close(62)
         
 11   call readproc(more)
 10   continue
      if (iline(iline(0)).ne.dipart(1)) goto 11

      if(proc_number.le.9) then
         cpn=char(48)//char(48)//char(proc_number+48)
      elseif(proc_number.le.99) then
         cpn=char(48)//char(proc_number/10+48)
     &        //char(mod(proc_number,10)+48) 
      elseif(proc_number.le.999) then
         cpn=char(proc_number/100+48)
     &        //char((proc_number-(proc_number/100)*100)/10+48)
     &        //char(mod(proc_number-(proc_number/100)*100,10)+48)
      endif

      do i=1,iline(0)
       mass(i)=str(2,iline(i))
      enddo


c calculating the symmetry factor of the n+1 process
      do i=1,maxlines
       ipart(i)=i
      enddo
      call getdenom(isymn1,initc,jhel,step,ipart)

c copy the process to to iline_orig
      do k=-maxlines,maxlines
       iline_orig(k)=iline(k)
      enddo

c copy the original process in which we can start combining particles to dipoles
      do k=1,maxdipoles
        do l=-maxlines,maxlines
          iline_copy(l,k)=iline_orig(l)
        enddo
        iline_copy(0,k)=iline_copy(0,k)-1
      enddo

      nr=0  ! no dipoles found yet...

c Loop over all particles in the process
      do i=1,iline(0)
c$$$      do j=nincoming+1,iline(0) ! unresolved is always final state -> start do loop at nincoming+1
      do j=iline(0),iline(0) ! set the unresolved to the last particle in the process. This should be a gluon
      do k=1,iline(0)
      if(i.ne.j .and. j.ne.k .and. i.ne.k) then !emitter, unresolved & spectator cannot be the same particle
c test if all of them are QCD particles
         qcd_part=0
         if ( info_p(1,iline(i)).gt.1.and.
     &        info_p(1,iline(j)).gt.1.and.mass(j).eq.'ZERO'.and. ! unresolved should be massless
     &        info_p(1,iline(k)).gt.1) qcd_part=3

c***********************************************************************************************
c If found that they are QCD particles try testing if they can be defined as
c emitter, unresolved and spectator
c this fills the array info_ijk(a,b,c), where
c a) goes from 1 to nr, where nr is the total number of dipoles found
c b) goes from 1 to 2, where 1 denotes the particle as iline number,
c                      and 2 the particle as type (gluon or (anti-quark))
c c) goes from 1 to 5, denoting the 1: emitter
c                                   2: unresolved
c                                   3: emitter and unresolved combined (i.e. before branching)
c                                   4: spectator
c                                   5: spectator before branching
c***********************************************************************************************
         if(qcd_part.eq.3) then
            do l=-maxlines,maxlines
               iline(l)=iline_orig(l) ! set process to the original process
            enddo
c    1. final-final
            if(i.gt. nincoming .and. j.gt. nincoming) then
c    1.1 combine final state q-qbar pair
               if ( iline(i).eq.inverse(iline(j)) .and.
     &              info_p(1,iline(i)).eq.3) then
                  nr=nr+1
                  iline_copy(min(i,j),nr)=dipart(1) ! sum should be gluon
                  do l=max(i,j),iline(0)
                     iline_copy(l,nr)=iline(l+1)
                  enddo
                  iline_copy(iline(0),nr)=0
                  info_ijk(nr,1,1)=i ! emitter
                  info_ijk(nr,1,2)=j ! unresolved
                  info_ijk(nr,2,1)=3        ! emitter is color triplet
                  info_ijk(nr,2,2)=3        ! unresolved is color triplet
                  info_ijk(nr,1,4)=k        ! spectator
                  info_ijk(nr,1,3)=min(i,j) ! emitter before branching
                  info_ijk(nr,2,3)=8        ! emitter before branching is color octet
                  if(k.gt.max(i,j)) then
                     info_ijk(nr,1,5)=k-1   ! spectator before branching
                  else
                     info_ijk(nr,1,5)=k     ! spectator before branching
                  endif
                  if(info_p(1,iline(k)).eq.8) then !spectator is color octet
                     info_ijk(nr,2,4)=8     ! spectator is color octet
                  else
                     info_ijk(nr,2,4)=3     ! spectator is color triplet
                  endif
                  info_ijk(nr,2,5)=info_ijk(nr,2,4) ! spectator does not change after branching
               endif
            endif
c    2.1 combine intial q/qbar with final state q/qbar 
            if(i.le.nincoming .and. j.gt.nincoming) then
               if ( info_p(1,iline(i)).eq.3 .and.
     &              info_p(1,iline(j)).eq.3 .and.
     &              iline(i).eq.inverse(iline(j))) then ! two color triplets
                  nr=nr+1
                  iline_copy(i,nr)=dipart(1) ! two triplets combine to gluon
                  do l=j,iline(0)
                     iline_copy(l,nr)=iline(l+1)
                  enddo
                  iline_copy(iline(0),nr)=0
                  info_ijk(nr,1,1)=i ! emitter
                  info_ijk(nr,1,2)=j ! unresolved
                  info_ijk(nr,1,4)=k ! spectator
                  info_ijk(nr,1,3)=i ! emitter before branching
                  info_ijk(nr,2,1)=3 ! emitter is triplet
                  info_ijk(nr,2,2)=3 ! unresolved is triplet
                  info_ijk(nr,2,3)=8 ! emitter before branching octet
                  if(k.gt.j) then
                     info_ijk(nr,1,5)=k-1 ! spectator before branching
                  else
                     info_ijk(nr,1,5)=k   ! spectator before branching
                  endif
                  if(info_p(1,iline(k)).eq.8) then !spectator is octet
                     info_ijk(nr,2,4)=8 ! spectator is octet
                  else
                     info_ijk(nr,2,4)=3 ! spectator is triplet
                  endif
                  info_ijk(nr,2,5)=info_ijk(nr,2,4) ! spectator does not change after branching
               endif
            endif
c    2. combine final state gluon with initial or final state parton
            if(j.gt.nincoming) then
               if(iline(j).eq.dipart(1)) then
                  nr=nr+1
                  do l=j,iline(0)
                     iline_copy(l,nr)=iline(l+1)
                  enddo
                  iline_copy(iline(0),nr)=0
                  info_ijk(nr,1,1)=i
                  info_ijk(nr,1,2)=j
                  info_ijk(nr,2,2)=8
                  info_ijk(nr,1,4)=k
                  if(j.gt.i) then
                     info_ijk(nr,1,3)=i
                  else
                     info_ijk(nr,1,3)=i-1
                  endif
                  if(j.gt.k) then
                     info_ijk(nr,1,5)=k
                  else
                     info_ijk(nr,1,5)=k-1
                  endif
                  if(info_p(1,iline(i)).eq.8) then
                     info_ijk(nr,2,1)=8
                     info_ijk(nr,2,3)=8
                  else
                     info_ijk(nr,2,1)=3
                     info_ijk(nr,2,3)=3
                  endif
                  if(info_p(1,iline(k)).eq.8) then
                     info_ijk(nr,2,4)=8
                  else
                     info_ijk(nr,2,4)=3
                  endif
                  info_ijk(nr,2,5)=info_ijk(nr,2,4)
               endif
            endif
            
c    2.2 combine initial gluon with final quark/antiquark
            if(i.le.nincoming .and. j.gt.nincoming) then
               if(iline(i).eq.dipart(1).and.iline(j).ne.dipart(1)) then
                  nr=nr+1
                  iline_copy(i,nr)=iline(j)
                  do l=j,iline(0)
                     iline_copy(l,nr)=iline(l+1)
                  enddo
                  iline_copy(iline(0),nr)=0
                  info_ijk(nr,1,1)=i
                  info_ijk(nr,1,2)=j
                  info_ijk(nr,1,4)=k
                  info_ijk(nr,1,3)=i
                  info_ijk(nr,2,1)=8
                  info_ijk(nr,2,2)=3
                  info_ijk(nr,2,3)=3
                  if(k.gt.j) then
                     info_ijk(nr,1,5)=k-1
                  else
                     info_ijk(nr,1,5)=k
                  endif
                  if(info_p(1,iline(k)).eq.8) then
                     info_ijk(nr,2,4)=8
                  else
                     info_ijk(nr,2,4)=3
                  endif
                  info_ijk(nr,2,5)=info_ijk(nr,2,4)
               endif
            endif
            
         endif
      endif
      enddo
      enddo
      enddo
c  this terminates all the loops over the particles in the process.

      if (nr.gt.maxdipoles)then
         write (*,*) 'ERROR: FOUND TOO MANY DIPOLES', nr
         write (*,*) 'INCREASE MAXDIPOLES IN params.inc'
      endif


c Remove dipole if already generated before and update the iline_copy
c Also remove all but 1 dipole that do not belong to gluon splitting, because then 
c no spectator is needed
c$$$      do i=1,nr
c$$$         write (*,*) i,'a',(info_ijk(i,1,l),l=1,5)
c$$$         write (*,*) i,'a',(info_ijk(i,2,l),l=1,5)
c$$$      enddo
      if (nr.gt.maxdipoles)then
         write (*,*) 'ERROR #1: FOUND TOO MANY DIPOLES', nr
         write (*,*) 'INCREASE MAXDIPOLES IN params.inc'
         stop
      endif
      call removelines(iline_copy)
c$$$      do i=1,nr
c$$$         write (*,*) i,'b',(info_ijk(i,1,l),l=1,5)
c$$$         write (*,*) i,'b',(info_ijk(i,2,l),l=1,5)
c$$$      enddo
      if (2*nr.gt.maxdipoles)then
         write (*,*) 'ERROR #2: FOUND TOO MANY DIPOLES', nr
         write (*,*) 'INCREASE MAXDIPOLES IN params.inc'
         stop
      endif
      call doublelines(iline_copy)
c$$$      do i=1,nr
c$$$         write (*,*) i,'c',(info_ijk(i,1,l),l=1,5)
c$$$         write (*,*) i,'c',(info_ijk(i,2,l),l=1,5)
c$$$      enddo
      call removelines_fks(iline_copy)

c$$$      do i=1,nr
c$$$         write (*,*) i,'d',(info_ijk(i,1,l),l=1,5),'    ',
c$$$     &        (info_p(5,iline_copy(l,i)),l=1,iline(0))
c$$$         write (*,*) i,'d',(info_ijk(i,2,l),l=1,5)
c$$$      enddo
c$$$      write (*,*) 'nr',nrs,nrc,nr
c$$$      stop

      notfound=0
c loop over all dipoles
      dipol = 1
      do while (dipol .le. nr)
         nproc1=0
         graphnr=0
c$$$         more=.true.
c copy the dipole process over the original
         do l=0,iline(0)
            iline(l)=iline_copy(l,dipol)
         enddo
c    initialize flowinfo
         do l=1,max_particles
            flowinfo(l,1)=0
            flowinfo(l,2)=0
         enddo
         call getflowinfo1()
c$$$         open(unit=isubfile,file='subproc.txt',status='unknown')
c$$$         write(isubfile,'(a$)') 'PROCESS = '
         open(unit=22,status='unknown')
         open(unit=25,status='unknown')
         open(unit=26,status='unknown')
         
c Get name for the dipol: 'dipolXXX', where the first three characters
c label the dipol
         iname=12
         ascii_nr=dipol+48
         ascii_emitter=info_ijk(dipol,1,3)+48
         if (dipol.le.nrc) then
            mid = 'cl'
         else
            mid = 'sf'
         endif
c         write (*,*) dipol,mid,nrs,nrc,nr
         if(dipol.le.9) then
            number=char(48)//char(48)//char(dipol+48)
         elseif(dipol.le.99) then
            number=char(48)//char(dipol/10+48)
     &           //char(mod(dipol,10)+48) 
         elseif(dipol.le.999) then
            number=char(dipol/100+48)
     &           //char((dipol-(dipol/100)*100)/10+48)
     &           //char(mod(dipol-(dipol/100)*100,10)+48)
         endif
         name='b_'//mid//'_'//cpn//'_'//number

c      do while (more)
         open(unit=91,status='unknown') ! here are the calls to HELAS temporarly stored
         flows(0,0,0,0)=0
         sumgluons=.true.
         sumgluons=.false.
         wcount=0
         print*,' '
         next=iline(0)
         if (lwrite) then
            open (unit=34,file='props.inc',status='unknown')
            open (unit=35,file='configs.inc',status='unknown')
            open (unit=36,file='decayBW.inc',status='unknown')
            open (unit=37,file='python_data.txt',status='unknown')
            open (unit=59,file='ngraphs.inc',status='unknown')
         else
            open (unit=58,status='unknown')
            open (unit=34,status='unknown')
            open (unit=35,status='unknown')
            open (unit=36,status='unknown')
            open (unit=59,status='unknown')
            open (unit=37,status='unknown')
         endif

         call InsertFields(tops,graphs)
         call write_config(tops,-99) !Close out 35
         if (lwrite) then
            close(34)
            close(35)
            close(36)
            close(37)
            close(59)
         else
            close(34,status='delete')
            close(35,status='delete')
            close(36,status='delete')
            close(59,status='delete')
            close(37,status='delete')
         endif
 215     continue
c         print*,'here grpahs',graphs(0,0)
         if (graphs(0,0) .eq. 0) then
c          print*, 'No graphs for this process', (iline(i),i=1,iline(0))
            print*, 'No dipols found for this configuraton', (iline(i),i=1,iline(0))
            notfound=notfound+1
            close(58,status='delete')
c     no graphs for this dipol config. -> remove it from the list
            do l=dipol,nr
               do k=-maxlines,maxlines
                  iline_copy(k,l)=iline_copy(k,l+1)
               enddo
               do k=1,5
                  info_ijk(l,1,k)=info_ijk(l+1,1,k)
                  info_ijk(l,2,k)=info_ijk(l+1,2,k)
               enddo
            enddo
            nr=nr-1
            if (dipol.le.nrc)then
               nrc=nrc-1
            else
               nrs=nrs-1
            endif
         else
            print*,'There are ',graphs(0,0),' graphs.'
            graphcolor(0,0,0)=graphs(0,0) !Number of graphs
            print*,' '
            call saveproc(i,graphs(0,0))
            
c Set i=1, because otherwise we do not get all dipolXX.f files.
            i=1

c Do write the dipolXX.f files:
            lwrite=.true.
            if (i .gt. 0 .or. i .lt. -1) then !New Process 
               if (lwrite) then !(i<0  means found matched process abs(i))
                  lwrite=.false.
                  first_proc = .false. !Now have processes
                  call write_symmetry
                  if (dipol.gt.nrc)then
                     call square_dip(flows,sflows,info_ijk(dipol,1,3),
     &                    info_ijk(dipol,1,5),removedipole)
                     if (removedipole) then
                        write (*,*) 'removing dipole structure',
     &                       dipol,info_ijk(dipol,1,3),info_ijk(dipol,1,5)
                        graphs(0,0)=0
                        rewind 91
                        goto 215
                     endif
                  else
                     call square(flows,sflows)
                  endif
c$$$c Write postscripts of the diagrams
c$$$                  call gen_ps(graphs,tops,iline(0))
                  open(unit=99,status='unknown') ! Here is the color info temporarly stored
                  call matrixcolor(graphcolor,sflows)
                  rewind 99     ! Rewind color info before writing in writeamp
                  rewind 91     ! Rewind HELAS info before writing in writeamp
                  call writeamp(graphs(0,0),next,
     $                 goal_coup(2),goal_coup(1),i,flows)
                  close(99,status='delete')

                  if (dipol.eq.1)then
                     open(unit=itnum,file='leshouches_'//
     &                    cpn//'.inc',status='unknown')
                     call write_leshouche(flows, itnum, i) !(color,ilun,iproc)
                     close(itnum)
                  endif
                  do j=0,iline(0)
                     matchline(j)=iline(j)
                  enddo
               endif
            endif
            close(91,status='delete')
            close(58,status='delete')
            dipol = dipol+1
         endif
         close(35)
         write(*,*) 
         write(*,*) 
         
c$$$         close(unit=isubfile)

      enddo                     !loop over dipoles (nr)

c Write auto_dsig.f
      rewind 22
c$$$      call writedsig(iline(0),22,.false.)
      close(22,status='delete')
      close(25,status='delete')
      close(26,status='delete')

      if (notfound.eq.0) then
         open (unit=62,file='proc_label',status='old',access='append')
         write (buffer,'(2i5,2i10)')proc_number,iline(0),
     &        info_p(5,inverse(iline(1))),info_p(5,inverse(iline(2)))
         write (buffer(31:140),*) (info_p(5,iline(i)),i=3,iline(0))
         write (62,*) buffer
         close(62)
         open (unit=62,file='proc_number',status='old')
         read(62,*) proc_number
         proc_number=proc_number+1
         rewind(62)
         write(62,*) proc_number
         close(62)
         call write_fks()
      endif

c restore orgininal process and
c continue with the loop over multi-particles         
      iline(0)=iline(0)+1
      iline(iline(0))=iline_orig(iline(0))
      call readproc(more)
      if (more) goto 10

      write(*,*)
      write(*,*)
      write(*,*) 'Thank you for using MadGraph'
      write(*,*)
      open (unit=62,file='proc_number',status='old')
      read(62,*) proc_number
      proc_number=proc_number-1
      rewind(62)
      write(62,*) proc_number
      close(62)


      open (unit=9973,file='proc_couplings',status='unknown')
      write(9973,*) goal_coup(2)
      write(9973,*) goal_coup(1)
      close(9973)

      
      return
      end





      subroutine square_dip(flows,sflows,emitter,spectator,removedipole)
!**************************************************************************
!     Square terms and simplify to get color factors for flows
!**************************************************************************
      implicit none

! Constants

      include 'params.inc'
c      integer    maxlines,  maxfactors,  maxterms,    maxflows
c      parameter (maxlines=8,maxfactors=9,maxterms=250,maxflows=200)

! Arguments

      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      double precision  sflows(maxflows,maxflows)
      integer emitter,spectator
      logical removedipole

! Local Variables

      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer nflows,nfactors,nelements
      integer iflow,ifact,ielement,iterm,cterm,fterm
      integer cflow,cfact,cfactors
      integer i,j
      double precision sdiag
      integer sqcolor(0:2*maxlines,0:maxfactors,0:maxterms)
      
! Global Variables

      integer           isflows(2,maxflows,maxflows)
      common/to_isflow/isflows
      logical         sumgluons
      common/to_cflow/sumgluons

      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),maxigraphs,max_ifactor(maxterms),graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr
!-----------
! Begin Code
!-----------
      nflows=flows(0,0,0,0)
      sumgluons=.true.
      do iflow=1,nflows
c         write(*,*) 'Flow number ',iflow
c         call PrintColors(flows(0,0,0,iflow))
         call SimpColors(flows(0,0,0,iflow),-1)  !Sum over internal gluon
       
c         call PrintColors(flows(0,0,0,iflow))
      enddo
      do iflow=1,nflows
         do cflow=iflow,nflows
            do iterm=1,flows(0,0,0,iflow)
               nfactors=flows(0,0,iterm,iflow)
               do ifact=0,nfactors
                  nelements=abs(flows(0,ifact,iterm,iflow))
                  do ielement=0,nelements
                     color(ielement,ifact,iterm)=
     &                    flows(ielement,ifact,iterm,iflow)
                  enddo
               enddo
            enddo                    !have all terms copied
            color(0,0,0)=flows(0,0,0,iflow)    !This is number of terms
           call storecolor(color,iflow)
        enddo
      enddo
      call clearzeros(color)
      call insertdipol(color,emitter,spectator)
      call doublecolor_tot(color,emitter,spectator)
      do iflow=1,nflows
         do cflow=iflow,nflows
             isflows(1,iflow,cflow)=0
             isflows(2,iflow,cflow)=0
             isflows(1,cflow,iflow)=0
             isflows(2,cflow,iflow)=0
             call squarecolor_tot(color,color_tot,sqcolor,iflow,cflow,max_ifactor,emitter,spectator)
             call dipolcolormatrix(sqcolor,color,iflow,cflow,emitter,spectator)
            if (color(0,0,0) .ge. 1) then
               isflows(1,iflow,cflow)=color(1,1,1)
               isflows(2,iflow,cflow)=color(2,1,1)
               isflows(1,cflow,iflow)=color(1,1,1)
               isflows(2,cflow,iflow)=color(2,1,1)
               sflows(iflow,cflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               sflows(cflow,iflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               if (color(0,0,0) .gt. 1) then
                  print*,'Error More than one term',color(0,0,1)
                  call printcolors(color)
               elseif (color(0,0,1) .gt. 1) then !one factor
                  print*,'One term but many factors',color(0,0,1),
     &                 iflow,cflow,color(1,1,1)
                  call printcolors(color)
               endif
            else
               isflows(1,iflow,cflow)=0
               isflows(2,iflow,cflow)=0
               sflows(iflow,cflow)=0.d0
               sflows(cflow,iflow)=0.d0
            endif
         enddo
      enddo
      removedipole=.true.
      do iflow=1,nflows
         do cflow=iflow,nflows
            if(isflows(1,iflow,cflow).ne.0 .or.
     &           isflows(2,iflow,cflow).ne.0) then
               removedipole=.false.
               return
            endif
         enddo
      enddo

      end






      subroutine square(flows,sflows)
!**************************************************************************
!     Square terms and simplify to get color factors for flows
!**************************************************************************
      implicit none

! Constants

      include 'params.inc'
c      integer    maxlines,  maxfactors,  maxterms,    maxflows
c      parameter (maxlines=8,maxfactors=9,maxterms=250,maxflows=200)

! Arguments

      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      double precision  sflows(maxflows,maxflows)

! Local Variables

      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer nflows,nfactors,nelements
      integer iflow,ifact,ielement,iterm,cterm,fterm
      integer cflow,cfact,cfactors
      integer i,j
      double precision sdiag
      
! Global Variables

      integer           isflows(2,maxflows,maxflows)
      common/to_isflow/isflows
      logical         sumgluons
      common/to_cflow/sumgluons
!-----------
! Begin Code
!-----------
      nflows=flows(0,0,0,0)
      sumgluons=.true.
      do iflow=1,nflows
c         write(*,*) 'Flow number ',iflow
c         call PrintColors(flows(0,0,0,iflow))
         call SimpColors(flows(0,0,0,iflow),-1)  !Sum over internal gluon
c         call PrintColors(flows(0,0,0,iflow))
      enddo
      do iflow=1,nflows
         do cflow=iflow,nflows
            do iterm=1,flows(0,0,0,iflow)
               nfactors=flows(0,0,iterm,iflow)
               do ifact=0,nfactors
                  nelements=abs(flows(0,ifact,iterm,iflow))
                  do ielement=0,nelements
                     color(ielement,ifact,iterm)=
     &                    flows(ielement,ifact,iterm,iflow)
                  enddo
               enddo
            enddo                    !have all terms copied
            color(0,0,0)=flows(0,0,0,iflow)    !This is number of terms
            do cterm=2,flows(0,0,0,cflow)
               do iterm=1,flows(0,0,0,iflow)
                  call copyterm(color,iterm,-999,-999)
               enddo
            enddo              !now we have enough set for all square terms
            do cterm=1,flows(0,0,0,cflow)
               cfactors=flows(0,0,cterm,cflow)
               do iterm=1,flows(0,0,0,iflow)
                  nfactors=flows(0,0,iterm,iflow)
                  fterm = flows(0,0,0,iflow)*(cterm-1)+iterm
                  color(0,0,fterm) = nfactors+cfactors-1
                  color(0,1,fterm) = 2 !num and denom
                  color(1,1,fterm) = color(1,1,fterm)*
     &                 flows(1,1,cterm,cflow)
                  color(2,1,fterm) = color(2,1,fterm)*
     &                 flows(2,1,cterm,cflow)
                  do cfact=2,cfactors
                     nelements=abs(flows(0,cfact,cterm,cflow))
                     color(0,nfactors+cfact-1,fterm)=
     &                    flows(0,cfact,cterm,cflow)
                     if (flows(0,cfact,cterm,cflow) .lt. 0) then !T Matrix
                        color(1,cfact+nfactors-1,fterm) =
     &                       flows(2,cfact,cterm,cflow)
                        color(2,cfact+nfactors-1,fterm) =
     &                          flows(1,cfact,cterm,cflow)
                        do ielement=3,nelements
                           color(ielement,cfact+nfactors-1,fterm)=
     &                          flows(nelements-ielement+3,cfact,
     &                          cterm,cflow)
                        enddo
                     else
                        do ielement=1,nelements
                           color(ielement,cfact+nfactors-1,fterm)=
     &                          flows(nelements-ielement+1,cfact,
     &                          cterm,cflow)
                        enddo
                     endif
                  enddo
               enddo
            enddo
            call simpcolors(color,1)
            call addterms(color)
            if (color(0,0,0) .ge. 1) then
               isflows(1,iflow,cflow)=color(1,1,1)
               isflows(2,iflow,cflow)=color(2,1,1)
               isflows(1,cflow,iflow)=color(1,1,1)
               isflows(2,cflow,iflow)=color(2,1,1)
               sflows(iflow,cflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               sflows(cflow,iflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               if (color(0,0,0) .gt. 1) then
                  print*,'Error More than one term',color(0,0,1)
                  call printcolors(color)
               elseif (color(0,0,1) .gt. 1) then !one factor
                  print*,'One term but many factors',color(0,0,1),
     &                 iflow,cflow,color(1,1,1)
                  call printcolors(color)
               endif
            else
               sflows(iflow,cflow)=0.d0
               sflows(cflow,iflow)=0.d0
            endif
         enddo
      enddo
      end

               

      Subroutine removelines(iline_copy)
!***********************************
! Removes dipoles that are identical to dipoles
! already calculated.
!**********************************
      implicit none
      include 'params.inc'

c     Arguments
      integer iline_copy(-maxlines:maxlines,maxdipoles)

c    Global
      integer info_ijk(maxdipoles,2,5),nr,nrs,nrc
      logical offdiag
      common /ijk/ info_ijk,nr, nrs,nrc,offdiag

c     Local
      integer i,j,k,l
      logical same,identlines




      identlines=.true.
      do while(identlines)
      identlines=.false.
      do i=1,nr-1
       do j=i+1,nr
        same=.true.
        do k=-maxlines,maxlines
         if(iline_copy(k,i).ne.iline_copy(k,j)) then
           same=.false.
         endif
        enddo
        if((info_ijk(i,1,1).ne.info_ijk(j,1,1)).or.
     &     (info_ijk(i,1,2).ne.info_ijk(j,1,2)).or.
     &     (info_ijk(i,1,4).ne.info_ijk(j,1,4))) then
           same=.false.
        endif

        if(same.eqv..true.) then
         identlines=.true.
         do l=j,nr
          do k=-maxlines,maxlines
           iline_copy(k,l)=iline_copy(k,l+1)
          enddo
          do k=1,5
           info_ijk(l,1,k)=info_ijk(l+1,1,k)
           info_ijk(l,2,k)=info_ijk(l+1,2,k)
          enddo
         enddo
         nr=nr-1
        endif
       enddo
      enddo
      enddo

      nrs=nr

      end



      Subroutine doublelines(iline_copy)
!***********************************
! Double the dipoles
!**********************************
      implicit none
      include 'params.inc'

c     Arguments
      integer iline_copy(-maxlines:maxlines,maxdipoles)

c    Global
      integer info_ijk(maxdipoles,2,5),nr,nrs,nrc
      logical offdiag
      common /ijk/ info_ijk,nr, nrs,nrc,offdiag

c     Local
      integer i,j,k,l
      logical same,identlines

      do i=1,nrs
         do k=-maxlines,maxlines
            iline_copy(k,i+nrs)=iline_copy(k,i)
         enddo
         do j=1,2
            do k=1,5
               info_ijk(i+nrs,j,k)=info_ijk(i,j,k)
            enddo
         enddo
      enddo
      nrc=nrs
      nr=2*nrs
      end




      Subroutine removelines_fks(iline_copy)
!***********************************
! Removes dipoles that are identical to dipoles
! already calculated. Ignore the spectator in this process
!**********************************
      implicit none
      include 'params.inc'

c     Arguments
      integer iline_copy(-maxlines:maxlines,maxdipoles)

c    Global
      integer info_ijk(maxdipoles,2,5),nr,nrs,nrc
      logical offdiag
      common /ijk/ info_ijk, nr, nrs,nrc,offdiag

      integer dipart(2*maxlines),dum,iline_orig(-maxlines:maxlines)
      common/to_dipart/dipart,dum,iline_orig

      character*(8) mass(max_particles)
      common /masses/ mass

c     Local
      integer i,j,k,l
      logical same,identlines
      

c No soft singularity if unresolved is quark
      i=nrc
      do while (i.lt.nrc+nrs)
         i=i+1
         if (abs(info_ijk(i,2,2)).eq.3)then
             do l=i,nr
               do k=-maxlines,maxlines
                  iline_copy(k,l)=iline_copy(k,l+1)
               enddo
               do k=1,5
                  info_ijk(l,1,k)=info_ijk(l+1,1,k)
                  info_ijk(l,2,k)=info_ijk(l+1,2,k)
               enddo
            enddo
            i=i-1
            nrs=nrs-1
            nr=nr-1
         endif
      enddo
         
c This will remove all the excess dipoles below if
c collinear singularity.
c Leaves only 1 dipole per emitter/unresolved
      do i=1, nrc
         info_ijk(i,1,4)=0
         info_ijk(i,1,5)=0
         info_ijk(i,2,4)=99
         info_ijk(i,2,5)=99
      enddo



      identlines=.true.
      do while(identlines)
         identlines=.false.
         do i=1,nrc-1
            do j=i+1,nrc
               same=.true.
               do k=-maxlines,maxlines
                  if(iline_copy(k,i).ne.iline_copy(k,j)) then
                     same=.false.
                  endif
               enddo
               if((info_ijk(i,1,1).ne.info_ijk(j,1,1)).or.
     &              (info_ijk(i,1,2).ne.info_ijk(j,1,2)).or.
     &              (info_ijk(i,1,4).ne.info_ijk(j,1,4))) then
                  same=.false.
               endif

c  if  ij=ji so ji needs to be removed if j cannot go soft (j != gluon)
               if ( (info_ijk(i,1,1).eq.info_ijk(j,1,2)) .and.
     &              (info_ijk(i,1,2).eq.info_ijk(j,1,1)) .and.
     &              (info_ijk(i,1,4).eq.info_ijk(j,1,4)) .and.
     &              .not.(info_ijk(j,2,2).eq.8 .and.
     &                     mass(info_ijk(j,1,2)).eq.'ZERO'))then
                  same=.true.
               endif
               if(same.eqv..true.) then
                  identlines=.true.
                  do l=j,nr
                     do k=-maxlines,maxlines
                        iline_copy(k,l)=iline_copy(k,l+1)
                     enddo
                     do k=1,5
                        info_ijk(l,1,k)=info_ijk(l+1,1,k)
                        info_ijk(l,2,k)=info_ijk(l+1,2,k)
                     enddo
                  enddo
                  nrc=nrc-1
               endif
            enddo
         enddo
      enddo

      nr=nrs+nrc

      end


      Subroutine write_fks()
!***************************************
! writes all possible fks_i and fks_j's
!***************************************

      implicit none

      include 'params.inc'

      integer info_ijk(maxdipoles,2,5),nr,nrs,nrc
      logical offdiag
      common /ijk/ info_ijk,nr,nrs,nrc,offdiag

      character*70       cversion
      common/to_version/ cversion

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      character*(8) mass(max_particles)
      common /masses/ mass

      integer dipart(2*maxlines),dum,iline_orig(-maxlines:maxlines)
      common/to_dipart/dipart,dum,iline_orig

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c

c     Local
      integer ln,i,ascii_emitter,ascii_spectator,ascii_nr
      integer nrdipol,nsout,l,j,number,temp(0:maxdipoles)
      parameter (ln=81)
      logical found,already

      integer fks_ipos(0:max_particles)
      integer fks_j_from_i(max_particles,0:max_particles)
      integer valid_i,valid_j
      logical same,massive
      character*70 buff
      character*3 s,sl
      character*3 cpn
      common/ccpn/cpn

c      integer pdgfromdipart(13)
c      data (pdgfromdipart(i),i=1,13) /2,-2,1,-1,3,-3,4,-4,5,-5,6,-6,21/



      nrdipol=nr
      if(nrdipol.eq.0) nrdipol=1

      open(unit=ln,file='sborn_sf_'//cpn//'.f',status='unknown')
c write out a file that links the i_fks with a given n and m for
c spectator and emittor to a color linked born      
      if (nrs.le.9) then
         s=char(nrs+48)
      elseif(nrs.le.99)then
         s=char(nrs/10+48)//char(mod(nrs,10)+48)
      elseif(nrs.le.999) then
         s=char(nrs/100+48)
     &        //char((nrs-(nrs/100)*100)/10+48)
     &        //char(mod(nrs-(nrs/100)*100,10)+48)
      endif

      write (ln,*) '     subroutine sborn_sf_'//cpn//'(p_born,wgtjk)'
      write (ln,*) '     implicit none'
      write (ln,*) '     include "nexternal.inc"'
      write (ln,*) '     double precision p_born(0:3,nexternal-1),wgt,'
      write (ln,*) '    &    wgtjk(nexternal-1,nexternal-1)'
      write (ln,*) '     integer m,n'
      write (ln,*) ''
      write (ln,*) '     do m=1,nexternal-2'
      write (ln,*) '     do n=m+1,nexternal-1'
      write (ln,*) ''
      if (nrs.ne.0) then
         do i=1,nrs
            if (i.eq.1)then
               write (ln,*) '     if ( m.eq.',info_ijk(i+nrc,1,1),
     &              ' .and. n.eq.',info_ijk(i+nrc,1,4),' ) then'
            else
               write (ln,*) '     elseif ( m.eq.',info_ijk(i+nrc,1,1),
     &              ' .and. n.eq.',info_ijk(i+nrc,1,4),' ) then'
            endif
            if (i+nrc.le.9) then
               sl='00'//char((i+nrc)+48)
            elseif(i+nrc.le.99)then
               sl='0'//char((i+nrc)/10+48)//char(mod((i+nrc),10)+48)
            elseif(i+nrc.le.999) then
               sl=char((i+nrc)/100+48)
     &              //char(((i+nrc)-((i+nrc)/100)*100)/10+48)
     &              //char(mod((i+nrc)-((i+nrc)/100)*100,10)+48)
            endif
            write (ln,*) '        call sb_sf_'//cpn//'_'
     &           //sl//'(p_born,wgt)'
         enddo
         write (ln,*) '     else'
         write (ln,*) '        wgt=0d0'
         write (ln,'(a)') 'c         write (*,*)'
         write (ln,'(a)') 'c     &      "No corresponding color '//
     &        'linked Born found in sborn_sf"'
         write (ln,*) '     endif'
      elseif (nrs.eq.0) then
         write (ln,*) '     write (*,*)'//
     &        ' "ERROR, this routine is a dummy!"'
         write (ln,*) '     stop'
      endif
      write (ln,*) ''
      write (ln,*) '     wgtjk(m,n)=-wgt'
      write (ln,*) '     wgtjk(n,m)=wgtjk(m,n)'
      write (ln,*) '     enddo ! loop over color-links'
      write (ln,*) '     enddo ! loop over color-links'
      write (ln,*) ''
c Self-eikonals
      write (ln,*) '     do m=1,nexternal-1'
      write (ln,*) '        wgtjk(m,m)=0d0'
      write (ln,*) '        do n=1,nexternal-1'
      write (ln,*) '           if (n.ne.m) '//
     &     'wgtjk(m,m)=wgtjk(m,m)-wgtjk(n,m)'
      write (ln,*) '        enddo'
      write (ln,*) '     enddo'
      write (ln,*) ''
      write (ln,*) ''
      write (ln,*) '     return'
      write (ln,*) '     end'


      open(unit=ln,file='sborn_cl_'//cpn//'.f',status='unknown')
      if (nrc.le.9) then
         s=char(nrc+48)
      elseif(nrc.le.99)then
         s=char(nrc/10+48)//char(mod(nrc,10)+48)
      elseif(nrc.le.999) then
         s=char(nrc/100+48)
     &        //char((nrc-(nrc/100)*100)/10+48)
     &        //char(mod(nrc-(nrc/100)*100,10)+48)
      endif
      write (ln,*) '     subroutine sborn_cl_'//cpn
     &     //'(p_born,wgtmunu,wgt)'
      write (ln,*) '     implicit none'
      write (ln,*) '     include "nexternal.inc"'
      write (ln,*) '     double precision p_born(0:3,nexternal-1),'//
     &     'wgt(0:nexternal-1),'
      write (ln,*) '    &    wgtmunu(0:3,0:3,nexternal-1)'
      write (ln,*) '     double complex wgt1(2),wm(6),wp(6),'
     &     //'wms(6),wps(6),cwgtmunu(0:3,0:3)'
      write (ln,*) '     integer i,j,leg'
      write (ln,*) ''
      write (ln,*) '     do leg=1,nexternal-1'
      write (ln,*) ''
      write (ln,*) '     wgt1(1)=(0d0,0d0)'
      write (ln,*) '     wgt1(2)=(0d0,0d0)'
      write (ln,*) '     wgt(0) = 0d0'
      write (ln,*) '     do i=1,4'
      write (ln,*) '        wm(i) = 0d0'
      write (ln,*) '        wp(i) = 0d0'
      write (ln,*) '        wms(i)= 0d0'
      write (ln,*) '        wps(i)= 0d0'
      write (ln,*) '     enddo'
      write (ln,*) '     '
      if (nrc.ne.0) then
         do i=1,nrc
            if (i.eq.1)then
               write (ln,*)
     &              '     if ( leg.eq.',info_ijk(i,1,3),' ) then'
            else
               write (ln,*)
     &              '     elseif ( leg.eq.',info_ijk(i,1,3),' ) then'
            endif
            if (info_ijk(i,2,3).eq.8 .and.
     &           mass(info_ijk(i,1,3)).eq.'ZERO') then
               write (ln,*)
     &              '        call VXXXXX(p_born(0,leg),0d0, 1,-1,Wp)'
               write (ln,*)
     &              '        call VXXXXX(p_born(0,leg),0d0,-1,-1,Wm)'
               write (ln,*)
     &              '        call VXXXXX(p_born(0,leg),0d0, 1, 1,Wps)'
               write (ln,*)
     &              '        call VXXXXX(p_born(0,leg),0d0,-1, 1,Wms)'
            endif 
            if (i.le.9) then
               sl='00'//char((i)+48)
            elseif(i.le.99)then
               sl='0'//char((i)/10+48)//char(mod((i),10)+48)
            elseif(i.le.999) then
               sl=char((i)/100+48)
     &              //char(((i)-((i)/100)*100)/10+48)
     &              //char(mod((i)-((i)/100)*100,10)+48)
            endif
            write (ln,*) '        call sb_cl_'//cpn//'_'//
     &           sl//'(p_born,wgt1)'
            write (ln,*) '        wgt(0)=dble(wgt1(1))+dimag(wgt1(1))'
         enddo
         write (ln,*) '     endif'
      elseif (nrc.eq.0) then
         write (ln,*) '     write (*,*)'//
     &        ' "ERROR, this routine is a dummy!"'
         write (ln,*) '     stop'
      endif
      write (ln,*) ''
      write (ln,*) '     wgt(leg)=wgt(0)'
      write (ln,*) '     do i=0,3'
      write (ln,*) '        do j=0,3'
      write (ln,*) '           if (leg.le.2) then'
      write (ln,*) '              cwgtmunu(i,j)'//
     &     '= dble(wgt1(1))*wms(i+1)*wm(j+1)+'
      write (ln,*) '    &                      '//
     &     ' dimag(wgt1(1))*wps(i+1)*wp(j+1)+'
      write (ln,*) '    &                      '//
     &     '        wgt1(2)*wps(i+1)*wm(j+1)+'
      write (ln,*) '    &                      '//
     &     'dconjg(wgt1(2))*wms(i+1)*wp(j+1)'
      write (ln,*) '           else'
      write (ln,*) '              cwgtmunu(i,j)'//
     &     '= dble(wgt1(1))*wm(i+1)*wms(j+1)+'
      write (ln,*) '    &                      '//
     &     ' dimag(wgt1(1))*wp(i+1)*wps(j+1)+'
      write (ln,*) '    &                      '//
     &     '        wgt1(2)*wp(i+1)*wms(j+1)+'
      write (ln,*) '    &                      '//
     &     'dconjg(wgt1(2))*wm(i+1)*wps(j+1)'
      write (ln,*) '           endif'
      write (ln,*) '     !      if (dble(cwgtmunu(i,j)).ne.0d0) then'
      write (ln,*) '     !        if(dimag(cwgtmunu(i,j))/dble('//
     &     'cwgtmunu(i,j)).gt.1d-15) then'
      write (ln,*) '     !           write (*,*) "ERROR in sborn_'//
     &     'cl_'//cpn//': Bmunu is complex"'
      write (ln,*) '     !           stop'
      write (ln,*) '     !         endif'
      write (ln,*) '     !      endif'
      write (ln,*) '           wgtmunu(i,j,leg)=dble(cwgtmunu(i,j))'
      write (ln,*) '        enddo'
      write (ln,*) '     enddo'
      write (ln,*) ''
      write (ln,*) '     enddo ! loop over legs'
      write (ln,*) ''
      write (ln,*) '     return'
      write (ln,*) '     end'

 5    format('C ',A)
 6    format('C ',A24,X,I3)
 10   format(6X,A)
 11   format(5X,'& ',A)


      end








      Subroutine storecolor(color,iflow)
!**********************************************
! Stores color information of color(...) in larger
! color matrix color_tot(2,1000,0:2maxlines,0:maxterms)
!**********************************************

      implicit none

      include 'params.inc'

c    Arguments
      integer color(0:2*maxlines,0:maxfactors,0:maxterms),iflow

c    Local
      integer ifactor,nterms,iterm,i

c    Global
      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),
     .        maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      if(iflow .gt.graphnr) then
      graphnr=graphnr+1
      nterms=color(0,0,0)
      color_tot(1,graphnr,0,0,0)=color(0,0,0)

      do iterm=1,nterms
      max_ifactor(iterm)=color(0,0,iterm)
      color_tot(1,graphnr,1,1,iterm)=color(1,1,iterm)
      color_tot(1,graphnr,2,1,iterm)=color(2,1,iterm)

      do ifactor=0,max_ifactor(iterm)
       color_tot(1,graphnr,0,ifactor,iterm)=color(0,ifactor,iterm)
       color_tot(1,graphnr,1,ifactor,iterm)=color(1,ifactor,iterm)
       color_tot(1,graphnr,2,ifactor,iterm)=color(2,ifactor,iterm)
        if(abs(color(0,ifactor,iterm)) .gt.2) then
          do i=3,abs(color(0,ifactor,iterm))
            color_tot(1,graphnr,i,ifactor,iterm)=color(i,ifactor,iterm)
          enddo
        endif
      enddo
      enddo
      endif

      end


      Subroutine getflowinfo1()
!**********************************************
! Provides information whether the external particles
! are particles/antiparticles and in-/outgoing
!**********************************************

      implicit none
      include 'params.inc'

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup

c  Global
      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo
      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      integer dipart(2*maxlines),dum,iline_orig(-maxlines:maxlines)
      common/to_dipart/dipart,dum,iline_orig

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

c  Local
      integer i,l

      do i=1,iline(0)
         flowinfo(i,1)=0
         flowinfo(i,2)=0
      enddo

      do i=1,iline(0)
         if (info_p(1,iline(i)).gt.1) then ! colored particle
            if ( info_p(5,iline(i)).gt.0 .and.
     &           info_p(1,iline(i)).eq.3) then ! particle (triplet)
               if (i.le.nincoming) then
c     1. initial anti-quark
                  flowinfo(i,1)=0
                  flowinfo(i,2)=-1
               else
c     2. final quark
                  flowinfo(i,1)=1
                  flowinfo(i,2)=1
               endif

            elseif ( info_p(5,iline(i)).lt.0 .and.
     &               info_p(1,iline(i)).eq.3) then ! anti-particle (triplet)
               if (i.le.nincoming) then
c     3. initial quark
                  flowinfo(i,1)=0
                  flowinfo(i,2)=1
               else
c     4. final anti-quark
                  flowinfo(i,1)=1
                  flowinfo(i,2)=-1
               endif
            elseif(info_p(1,iline(i)).eq.8) then
c     5. gluon
               flowinfo(i,1)=0
               flowinfo(i,2)=0
            else
               write (*,*) 'ERROR #125',iline(i),info_p(1,iline(i))
               stop
            endif
         endif
      enddo

      return
      end


      Subroutine Insertdipol(color,emitter,spectator)
!******************************************
! Insert the color information of emitter and
! spectator in the color matrix color_tot
!*****************************************

      implicit none

      include 'params.inc'

c    Arguments
      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer emitter, spectator

c    Global
      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),
     .        maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str2(3,max_particles)
      integer info_p(5,max_particles),iposx(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str2

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

c    Local
      integer nterms,iterm,j

      do j=1,graphnr
      nterms=color_tot(1,j,0,0,0)
      do iterm=1,nterms
       max_ifactor(iterm)=color(0,0,iterm)!-1
c    quark as emitter
      if(flowinfo(emitter,2) .ne.0) then
        color_tot(1,j,0,max_ifactor(iterm)+1,iterm)=-3
c    final state quark or initial state anti-quark as emitter
        if((flowinfo(emitter,1) .eq. 1 .and. flowinfo(emitter,2).eq.1) .or.
     &      (flowinfo(emitter,1) .eq. 0 .and. flowinfo(emitter,2).eq.-1))then
          color_tot(1,j,1,max_ifactor(iterm)+1,iterm)=emitter+max_particles
          color_tot(1,j,2,max_ifactor(iterm)+1,iterm)=emitter
          color_tot(1,j,3,max_ifactor(iterm)+1,iterm)=-99
        endif
c    final state anti-quark or initial state quark as emitter
        if((flowinfo(emitter,1) .eq. 1 .and. flowinfo(emitter,2).eq.-1).or.
     &       (flowinfo(emitter,1) .eq. 0 .and. flowinfo(emitter,2).eq.1))then
          color_tot(1,j,1,max_ifactor(iterm)+1,iterm)=emitter
          color_tot(1,j,2,max_ifactor(iterm)+1,iterm)=emitter+max_particles
          color_tot(1,j,3,max_ifactor(iterm)+1,iterm)=-99
        endif
      endif

c    quark as spectator
       if(flowinfo(spectator,2).ne.0) then
        color_tot(1,j,0,max_ifactor(iterm)+2,iterm)=-3
c    final state quark or initial state anti-quark as spectator
        if((flowinfo(spectator,1) .eq. 1 .and. flowinfo(spectator,2).eq.1) .or.
     &      (flowinfo(spectator,1) .eq. 0 .and. flowinfo(spectator,2).eq.-1))then
          color_tot(1,j,1,max_ifactor(iterm)+2,iterm)=spectator+max_particles
          color_tot(1,j,2,max_ifactor(iterm)+2,iterm)=spectator
          color_tot(1,j,3,max_ifactor(iterm)+2,iterm)=-99
        endif
c    final state anti-quark or initial state quark as spectator
        if((flowinfo(spectator,1) .eq. 1 .and. flowinfo(spectator,2).eq.-1).or.
     &       (flowinfo(spectator,1) .eq. 0 .and. flowinfo(spectator,2).eq.1))then
          color_tot(1,j,1,max_ifactor(iterm)+2,iterm)=spectator
          color_tot(1,j,2,max_ifactor(iterm)+2,iterm)=spectator+max_particles
          color_tot(1,j,3,max_ifactor(iterm)+2,iterm)=-99
        endif
      endif
      

c    gluon as spectator
      if(flowinfo(spectator,2).eq.0) then
         color_tot(1,j,0,max_ifactor(iterm)+2,iterm)=3
         color_tot(1,j,1,max_ifactor(iterm)+2,iterm)=spectator+max_particles
         color_tot(1,j,2,max_ifactor(iterm)+2,iterm)=-99
         color_tot(1,j,3,max_ifactor(iterm)+2,iterm)=spectator
      endif

c    gluon as emitter
      if(flowinfo(emitter,2).eq.0) then
         color_tot(1,j,0,max_ifactor(iterm)+1,iterm)=3
         color_tot(1,j,1,max_ifactor(iterm)+1,iterm)=emitter+max_particles
         color_tot(1,j,2,max_ifactor(iterm)+1,iterm)=-99
         color_tot(1,j,3,max_ifactor(iterm)+1,iterm)=emitter
      endif

      enddo
      enddo
c      print*,'flowinfo'
c      print*, flowinfo(1,1),flowinfo(1,2)
c      print*, flowinfo(2,1),flowinfo(2,2)
c      print*, flowinfo(3,1),flowinfo(3,2)
c      print*, flowinfo(4,1),flowinfo(4,2)
c      print*, flowinfo(5,1),flowinfo(5,2)

      end



      Subroutine doublecolor_tot(color,emitter,spectator)
!***********************************************
! Calculates the conjugate color matrix of the
! amplitudes and stores it in color_tot(2,....)
!***********************************************

      implicit none

      include 'params.inc'

c    Arguments
      integer emitter,spectator
      integer color(0:2*maxlines,0:maxfactors,0:maxterms)


c    Global
      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),
     .        maxigraphs,max_ifactor(maxterms),graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str2(3,max_particles)
      integer info_p(5,max_particles),iposx(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str2

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

c    Local
      integer i,j,k,ifactor,factor,nterms,iterm,c,c1,ntermsmax,ratio,l,ncp
      logical ne,ns

      ntermsmax=1
      c=0
      if(flowinfo(spectator,2).eq.0) then
       c=c+1
      endif
      if(flowinfo(emitter,2).eq.0) then
       c=c+1
      endif
      do j=1,graphnr
       if(color_tot(1,j,0,0,0) .gt. ntermsmax) then
         ntermsmax=color_tot(1,j,0,0,0)
       endif
      enddo

      do j=1,graphnr
      nterms=color_tot(1,j,0,0,0)

      if(c.ne.0)then
       do iterm=1,nterms
        max_ifactor(nterms+iterm)=max_ifactor(iterm)
        color(0,0,nterms+iterm)=color(0,0,iterm) 
        color(0,1,nterms+iterm)=2
        color(1,1,nterms+iterm)=color(1,1,iterm)
        color(2,1,nterms+iterm)=color(2,1,iterm)
        color_tot(1,j,1,1,nterms+iterm)=color(1,1,nterms+iterm)
        color_tot(1,j,2,1,nterms+iterm)=color(2,1,nterms+iterm)
        color_tot(1,j,0,0,nterms+iterm)=color(0,0,nterms+iterm) 
       enddo
       do i=1,4*c**2
       do iterm=1,nterms
        color(0,0,i*nterms+iterm)=color(0,0,(i-1)*nterms+iterm) 
        color(0,1,i*nterms+iterm)=2
        max_ifactor(i*nterms+iterm)=max_ifactor((i-1)*nterms+iterm)
        color(1,1,i*nterms+iterm)=color(1,1,(i-1)*nterms+iterm)
        color(2,1,i*nterms+iterm)=color(2,1,(i-1)*nterms+iterm)
        color_tot(1,j,1,1,i*nterms+iterm)=color(1,1,(i-1)*nterms+iterm)
        color_tot(1,j,2,1,i*nterms+iterm)=color(2,1,(i-1)*nterms+iterm)
        color_tot(1,j,0,0,i*nterms+iterm)=color(0,0,(i-1)*nterms+iterm)
       enddo
       enddo
      endif

       do iterm=1,nterms
        do i=1,nterms-1
         max_ifactor(i*nterms+iterm)=max_ifactor(iterm)
        enddo
       enddo

c  if emitter or spectator is a gluon, enlarge colormatrix
      if(flowinfo(spectator,2).eq.0) then
       do iterm=1,nterms
c    copy terms
        do i=0,max_ifactor(iterm)+2
          do k=0,abs(color_tot(1,j,0,i,iterm))
          color_tot(1,j,k,i,nterms+iterm)=color_tot(1,j,k,i,iterm)
          enddo
        enddo
c    replace spectator term by modified one
        color_tot(1,j,0,max_ifactor(iterm)+2,nterms+iterm)=3
        color_tot(1,j,1,max_ifactor(iterm)+2,nterms+iterm)=spectator
        color_tot(1,j,2,max_ifactor(iterm)+2,nterms+iterm)=-99
        color_tot(1,j,3,max_ifactor(iterm)+2,nterms+iterm)=spectator+max_particles
       enddo

      endif

      if(flowinfo(emitter,2).eq.0) then
       if(flowinfo(spectator,2).ne.0)then
        do iterm=1,nterms
c    copy terms
        do i=0,max_ifactor(iterm)+2
          do k=0,abs(color_tot(1,j,0,i,iterm))
          color_tot(1,j,k,i,nterms+iterm)=color_tot(1,j,k,i,iterm)
          enddo
        enddo
c    replace emitter term by modified one
        color_tot(1,j,0,max_ifactor(iterm)+1,nterms+iterm)=3
        color_tot(1,j,1,max_ifactor(iterm)+1,nterms+iterm)=emitter
        color_tot(1,j,2,max_ifactor(iterm)+1,nterms+iterm)=-99
        color_tot(1,j,3,max_ifactor(iterm)+1,nterms+iterm)=emitter+max_particles
        enddo
       endif
       if(flowinfo(spectator,2).eq.0)then
        do iterm=1,2*nterms
c     copy terms
         do i=0,max_ifactor(iterm)+2
          do k=0,abs(color_tot(1,j,0,i,iterm))
           color_tot(1,j,k,i,2*nterms+iterm)=color_tot(1,j,k,i,iterm)
c          print*, j,i,iterm,k,color_tot(1,j,k,i,iterm)
          enddo
         enddo
        color_tot(1,j,0,max_ifactor(iterm)+1,2*nterms+iterm)=3
        color_tot(1,j,1,max_ifactor(iterm)+1,2*nterms+iterm)=emitter
        color_tot(1,j,2,max_ifactor(iterm)+1,2*nterms+iterm)=-99
        color_tot(1,j,3,max_ifactor(iterm)+1,2*nterms+iterm)=emitter+max_particles
        enddo
       endif
      endif

      if(c.ne.0) then
       c1=2*c
      else
        c1=1
      endif
       print*,ntermsmax,max_particles

c    copying numerator and denominator
      if(ntermsmax .gt. nterms) then
        do iterm=1,c1*nterms
         color(1,1,c1*nterms+iterm)=color(1,1,iterm)
         color(2,1,c1*nterms+iterm)=color(2,1,iterm)
         color_tot(1,j,1,1,c1*nterms+iterm)=color(1,1,c1*nterms+iterm)
         color_tot(1,j,2,1,c1*nterms+iterm)=color(2,1,c1*nterms+iterm)
         do i=1,2*max_ifactor(iterm)+2
          do k=0,abs(color_tot(1,j,0,i,iterm))
          color_tot(1,j,k,i,c1*nterms+iterm)=color_tot(1,j,k,i,iterm)
          enddo
         enddo
        enddo
      endif


      do iterm=1,c1*nterms
       ne=.true.
       ns=.true.
       max_ifactor(iterm)=color_tot(1,j,0,0,iterm)
       do ifactor=1,max_ifactor(iterm)
        color_tot(2,j,0,ifactor,iterm)=color_tot(1,j,0,ifactor,iterm)
        do k=1,7
         if(color_tot(1,j,k,ifactor,iterm).eq.emitter) ne=.false.
         if(color_tot(1,j,k,ifactor,iterm).eq. spectator) ns=.false.
        enddo


c    Kronecker Delta
        if(color_tot(1,j,0,ifactor,iterm) .eq. 2 .or. color_tot(1,j,0,ifactor,iterm) .eq. -2) then
c         do i=2,3
          if(color_tot(1,j,1,ifactor,iterm) .ne. 0) then
           if(color_tot(1,j,2,ifactor,iterm).eq.emitter .or. 
     &         color_tot(1,j,2,ifactor,iterm).eq.spectator.or.
     &         color_tot(1,j,2,ifactor,iterm).lt.0) then
               factor=1
           else
               factor=0
           endif
           color_tot(2,j,1,ifactor,iterm)
     &          = color_tot(1,j,2,ifactor,iterm)+
     &            sign(max_particles,color_tot(1,j,2,ifactor,iterm))*factor
          endif
          if(color_tot(1,j,2,ifactor,iterm) .ne. 0) then
           if(color_tot(1,j,1,ifactor,iterm).eq.emitter .or. 
     &         color_tot(1,j,1,ifactor,iterm).eq.spectator.or.
     &          color_tot(1,j,1,ifactor,iterm).lt.0) then
               factor=1
           else
               factor=0
           endif
           color_tot(2,j,2,ifactor,iterm)
     &          = color_tot(1,j,1,ifactor,iterm)+
     &            sign(max_particles,color_tot(1,j,1,ifactor,iterm))*factor
          endif
c         enddo
        endif

c   n colored particles
c   T[a,i,j]T[b,j,k]T[c,k,l]...
        if(color_tot(1,j,0,ifactor,iterm).le. -3 ) then
         ncp=abs(color_tot(1,j,0,ifactor,iterm))
           if(color_tot(1,j,2,ifactor,iterm).eq.emitter .or. 
     &         color_tot(1,j,2,ifactor,iterm).eq.spectator.or.
     &          color_tot(1,j,2,ifactor,iterm).lt.0) then
               factor=1
           else
               factor=0
           endif
          color_tot(2,j,1,ifactor,iterm) 
     &          = color_tot(1,j,2,ifactor,iterm)+
     &            sign(max_particles,color_tot(1,j,2,ifactor,iterm))*factor
           if(color_tot(1,j,1,ifactor,iterm).eq.emitter .or. 
     &         color_tot(1,j,1,ifactor,iterm).eq.spectator.or.
     &          color_tot(1,j,1,ifactor,iterm).lt.0) then
               factor=1
           else
               factor=0
           endif
          color_tot(2,j,2,ifactor,iterm) 
     &          = color_tot(1,j,1,ifactor,iterm)+
     &            sign(max_particles,color_tot(1,j,1,ifactor,iterm))*factor
          do l=3,ncp
           if(color_tot(1,j,ncp-l+3,ifactor,iterm).eq.emitter .or. 
     &         color_tot(1,j,ncp-l+3,ifactor,iterm).eq.spectator.or.
     &          color_tot(1,j,ncp-l+3,ifactor,iterm).lt.0) then
               factor=1
           else
               factor=0
           endif
          color_tot(2,j,l,ifactor,iterm) 
     &          = color_tot(1,j,ncp-l+3,ifactor,iterm)
     &            +sign(max_particles,color_tot(1,j,ncp-l+3,ifactor,iterm))*factor
          enddo

        endif

c   f[a,b,c]f[c,d,e]f[e,f,g]...
        if(color_tot(1,j,0,ifactor,iterm).ge. 3 ) then
         ncp=color_tot(1,j,0,ifactor,iterm)
         do l=1,ncp
           if(color_tot(1,j,ncp-l+1,ifactor,iterm).eq.emitter .or. 
     &         color_tot(1,j,ncp-l+1,ifactor,iterm).eq.spectator.or.
     &          color_tot(1,j,ncp-l+1,ifactor,iterm).lt.0) then
               factor=1
           else
               factor=0
           endif
          color_tot(2,j,l,ifactor,iterm) 
     &          = color_tot(1,j,ncp-l+1,ifactor,iterm)
     &            +sign(max_particles,color_tot(1,j,ncp-l+1,ifactor,iterm))*factor
         enddo
        endif

       enddo
       enddo


      enddo


      end


      Subroutine squarecolor_tot(color,color_tot,sqcolor,j,i,max_ifactor,emitter,spectator)
!********************************************
! Puts together color_tot(1,.....) of one amplitude
! and color_tot(2,....) of another amplitude into one
! color matrix sqcolor.
!********************************************

      implicit none

      include 'params.inc'

c    Arguments
      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms)
      integer sqcolor(0:2*maxlines,0:maxfactors,0:maxterms)
      integer i,j,max_ifactor(maxterms)
      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer emitter,spectator

c    Global
      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

c    Local
      integer c,k,ifactor,iterm,itermi,itermj,ntermsi,ntermsj,l,nterms,m

      c=0
      if(flowinfo(spectator,2).eq.0) then
       c=c+1
      endif
      if(flowinfo(emitter,2).eq.0) then
       c=c+1
      endif

      ntermsi=color_tot(1,i,0,0,0)
      ntermsj=color_tot(1,j,0,0,0)
      sqcolor(0,0,0)=ntermsi*ntermsj
      if(c.ne.0) then
       sqcolor(0,0,0)=sqcolor(0,0,0)*2*c
      endif
        nterms=sqcolor(0,0,0)

        if(flowinfo(spectator,2).eq.0) then
         if(color_tot(1,i,0,0,0).ne.color_tot(1,j,0,0,0)) then
          do iterm=1,min(color_tot(1,i,0,0,0),color_tot(1,j,0,0,0))
           color_tot(1,j,0,max_ifactor(iterm)+2,iterm)=3
           color_tot(1,j,1,max_ifactor(iterm)+2,iterm)=spectator+max_particles
           color_tot(1,j,2,max_ifactor(iterm)+2,iterm)=-99
           color_tot(1,j,3,max_ifactor(iterm)+2,iterm)=spectator
          enddo
          do iterm=min(color_tot(1,i,0,0,0),color_tot(1,j,0,0,0))+1,nterms
           color_tot(1,j,0,max_ifactor(iterm)+2,iterm)=3
           color_tot(1,j,1,max_ifactor(iterm)+2,iterm)=spectator
           color_tot(1,j,2,max_ifactor(iterm)+2,iterm)=-99
           color_tot(1,j,3,max_ifactor(iterm)+2,iterm)=spectator+max_particles
          enddo
         endif
        endif

        if(flowinfo(emitter,2).eq.0) then
          if(color_tot(1,i,0,0,0).ne.color_tot(1,j,0,0,0)) then
           do iterm=1,min(color_tot(1,i,0,0,0),color_tot(1,j,0,0,0))
            color_tot(1,j,0,max_ifactor(iterm)+1,iterm)=3
            color_tot(1,j,1,max_ifactor(iterm)+1,iterm)=emitter+max_particles
            color_tot(1,j,2,max_ifactor(iterm)+1,iterm)=-99
            color_tot(1,j,3,max_ifactor(iterm)+1,iterm)=emitter
           enddo
           do iterm=min(color_tot(1,i,0,0,0),color_tot(1,j,0,0,0))+1,nterms
            color_tot(1,j,0,max_ifactor(iterm)+1,iterm)=3
            color_tot(1,j,1,max_ifactor(iterm)+1,iterm)=emitter
            color_tot(1,j,2,max_ifactor(iterm)+1,iterm)=-99
            color_tot(1,j,3,max_ifactor(iterm)+1,iterm)=emitter+max_particles
           enddo
          endif
        endif

      l=1
      if(c.ne.0) then
       ntermsi=2*c*ntermsi
      endif
      do itermi=1,ntermsi
       do itermj=1,ntermsj
        do ifactor=0,max_ifactor(itermi)+2
         do k=0,abs(color_tot(1,i,0,ifactor,itermi))
          sqcolor(k,ifactor,l) =color_tot(1,i,k,ifactor,itermi)
         enddo
        enddo
        do ifactor=max_ifactor(itermi)+3,2*max_ifactor(itermi)+1
         do k=0,abs(color_tot(2,j,0,ifactor-max_ifactor(itermi)-1,itermj))
         sqcolor(k,ifactor,l)=color_tot(2,j,k,ifactor-max_ifactor(itermi)-1,itermj)
         enddo
        enddo
       l=l+1
       enddo
      enddo

      l=1
      do itermi=1,ntermsi
       do itermj=1,ntermsj
        sqcolor(1,1,l)=color_tot(1,i,1,1,itermi)*color_tot(1,j,1,1,itermj)
        sqcolor(2,1,l)=color_tot(1,i,2,1,itermi)*color_tot(1,j,2,1,itermj)
        l=l+1
       enddo
      enddo

      end



      Subroutine dipolcolormatrix(sqcolor,color,i,j,emitter,spectator)
!**************************************************
! Copies sqcolor into color an evaluates the color-
! factor and returns the output in the usual variable
! color(...).
!***************************************************

      implicit none
      include 'params.inc'

c    Arguments
      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer i,j,emitter,spectator,sqcolor(0:2*maxlines,0:maxfactors,0:maxterms)

c    Global
      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),
     .        maxigraphs,max_ifactor(maxterms),graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str2(3,max_particles)
      integer info_p(5,max_particles),iposx(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str2
      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup

      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst
c    Local
      integer k,l,m,n,listintern(4),m1,m2,iterm,nterms,c
      logical check

      c=0
      if(flowinfo(spectator,2).eq.0) then
       c=c+1
      endif
      if(flowinfo(emitter,2).eq.0) then
       c=c+1
      endif

       nterms=sqcolor(0,0,0)
      color(0,0,0)=nterms
      do iterm=1,nterms
      color(1,1,iterm)=sqcolor(1,1,iterm)
      color(2,1,iterm)=sqcolor(2,1,iterm)

      do k=0,2*max_ifactor(iterm)+2
       do l=0,abs(sqcolor(0,k,iterm))
       color(l,k,iterm)=sqcolor(l,k,iterm)
       enddo
      enddo
      color(0,0,iterm)=2*max_ifactor(iterm)+1
      enddo

c     modifying numerator and denominator
      if(c.eq.1) then
       do iterm=1, nterms/2
        color(1,1,nterms/2+iterm)=2*color(1,1,iterm)
        color(2,1,nterms/2+iterm)=color(2,1,iterm)
        color(1,1,iterm)=-2*color(1,1,iterm)
       enddo
      endif

      if(c.eq.2) then
       do iterm=1, nterms/2/c
        color(1,1,nterms/2/c+iterm)=2*color(1,1,iterm)
        color(1,1,iterm)=-2*color(1,1,iterm)
       enddo
       do iterm=1,nterms/2
        color(1,1,nterms/2+iterm)=color(1,1,iterm)
        color(2,1,nterms/2+iterm)=color(2,1,iterm)
       enddo
       do iterm=1,nterms/2
        color(1,1,iterm)=-2*color(1,1,iterm)
        color(1,1,nterms/2+iterm)=2*color(1,1,nterms/2+iterm)
       enddo
      endif


      do n=1,4
       listintern(n)=0
      enddo

      n=1
      check=.true.
      do iterm=1,nterms
      do m=2, 2*max_ifactor(iterm)+4
       do m1=1,3
        check=.true.
        if(color(m1,m,iterm) .lt.0 .and. color(m1,m,iterm) .ne. -99) then
         do m2=1,n
          if(color(m1,m,iterm).eq.listintern(m2)) check=.false.
         enddo
         if(check.eqv..true.) then
          listintern(n)=color(m1,m,iterm)
          n=n+1
         endif
        endif
       enddo
      enddo
      enddo


      n=1
      do while(listintern(n) .ne. 0)
        call sumcolors(color,listintern(n))
        call clearzeros(color)
        n=n+1
      enddo
c      call printdipolcolor(color)
      call sumcolors(color,-99)
      call orderF(color)
      call addterms(color)
c      call ordercolors(color)
      call sumcolors(color,emitter+max_particles)
      call clearzeros(color)
      call sumcolors(color,spectator+max_particles)
      call clearzeros(color)
      call simpcolors(color,1)
      call addterms(color)
      if((flowinfo(emitter,1) .eq. 1 .and. flowinfo(emitter,2).eq.-1).or.
     &       (flowinfo(emitter,1) .eq. 0 .and. flowinfo(emitter,2).eq.1))then
           color(1,1,1)=-color(1,1,1)
      endif
      if((flowinfo(spectator,1) .eq. 1 .and. flowinfo(spectator,2).eq.-1).or.
     &       (flowinfo(spectator,1) .eq. 0 .and. flowinfo(spectator,2).eq.1))then
           color(1,1,1)=-color(1,1,1)
      endif
      if(flowinfo(spectator,2).eq.0) color(1,1,1)=-color(1,1,1)
      if(flowinfo(emitter,2).eq.0) color(1,1,1)=-color(1,1,1)

c      print*, 'numerator and denominator: ',color(1,1,1),color(2,1,1)

      if(c.ne.0) then
       do k=1,graphnr
        color_tot(1,k,0,1,1)=color_tot(2,k,0,1,1)
       enddo
      endif

      end


