      Program QEDDipolterms

      implicit none

      include 'params.inc'
c     Global
      integer info_ijk(maxdipoles,2,5),nr
      common /ijk/ info_ijk,nr

      call madgraphqed

      call write_dipolsqed()
      call write_intdipolesqed()
      call write_dipoleinc()

      end






      Subroutine MADGRAPHqed()
!*************************************************************************
!     Main program for MadGraph
!*************************************************************************
      implicit none

! Constants

      include 'params.inc'


! Local Variables

      integer tops(0:4,0:maxnodes,0:maxtops)
      integer graphs(0:maxgraphs,0:maxlines) !graphs, topology internal lines
      integer next,i,ntopold,ii,j,idipol,i1
      double precision sflows(maxflows,maxflows)
      logical more, lpossible,foundborn,foundin,foundfi
      integer fortran,ascii_emitter,ascii_spectator,ascii_n,ascii_nr
      integer dum,m,dipart(2*maxlines),n,k,l,dum1,qed_part
      integer notfound
      character*70 buff
      integer ipart(maxlines),step(maxlines),jhel,initc

! External Functions
      logical qmatch_check

! Global Variables

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup
      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      integer iline_copy(-maxlines:maxlines,maxdipoles)
      common /to_writedipole/iline_copy

      character*25        name
      integer        iname
      common/to_name/iname,name
      integer alen(maxgraphs)
      integer wnum(-maxlines:maxlines),wcount,wlen(maxgraphs*maxlines)
      common/toopt/wcount,wnum,wlen,alen
      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      integer         graphcolor(0:2,0:maxflows,0:maxgraphs)
      common/to_color/graphcolor,flows
      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c

      logical          this_block(0:max_blocks), need_block(max_blocks)
      common/to_blocks/this_block              , need_block

      logical         sumgluons
      common/to_cflow/sumgluons

      logical              lwrite
      common/to_multiproc/ lwrite

      logical           jetloop
      common/to_jetloop/jetloop

      integer          matchline(0:maxlines)
      common/to_qmatch/matchline

      logical              cross_opt
      common /to_crossopt/ cross_opt

      character*70       cversion
      common/to_version/ cversion
      character*(40)       particleID, interactionID
      common/to_modelinput/particleID, interactionID

      logical             first_proc
      common/to_firstproc/first_proc

      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      integer dipollist(maxdipoles,2,2),nrdipols
      common /list/ dipollist,nrdipols

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer info_ijk(maxdipoles,2,5),nr,dipol
      common /ijk/ info_ijk,nr
      common /dipolenumber/dipol

      integer iline_orig(-maxlines:maxlines)
      common /ciline_orig/iline_orig

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

      real*8 chargeinfo(max_particles)
      integer chargint(2)
      common /charge_info/ chargeinfo,chargint

      integer wcount1(maxproc),acount1(maxproc)
      integer wlen1(maxgraphs*maxlines,maxproc)
      integer alen1(maxgraphs,maxproc),nproc1
      common/toglobal/wcount1,acount1,wlen1,alen1,nproc1

      integer isymn1
      common /isym/ isymn1

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

      character*(8) mass(max_particles)
      common /masses/ mass
! Data Table

! If you want the output function written using real*8 and complex*16
! style declarations, remove the comment character from the following
! line.

      data fortran /77/
      data interactionid /"???"/
      data particleid /"???"/

!-----------
! Begin Code
!-----------
c      open (unit=6, file='output.dat',status='unknown')
      cversion='Generated by MadGraph II'

      first_proc = .true.
      ntopold=0
c do not write extra files, only the dipol1234.f:
       lwrite=.false.
      call resetV
      call Load_Particles
      call Load_Interactions
      print*,' '
c      call writelogo
      print*,' '
      
 10   call readproc(more)

      call readphotonpdf

      do i=1,iline(0)
       mass(i)=str(2,iline(i))
      enddo


c calculating the symmetry factor of the n+1 process
      do i=1,maxlines
       ipart(i)=i
      enddo
      call getdenom(isymn1,initc,jhel,step,ipart)

c copy the process to to iline_orig
      do k=-maxlines,maxlines
       iline_orig(k)=iline(k)
      enddo

     
       call getchargeinfo()

      i1 = index(proc,'>')
c get all QED particles (do not change the order!)
      call getparticle('u u~ d d~ s s~ c c~ b b~ t t~ e+ e- mu+ mu- ta+ ta- w+ w- a',dipart,dum)

c copy the original process in which we can start combining particles to dipoles
      do k=1,maxdipoles
        do l=-maxlines,maxlines
          iline_copy(l,k)=iline_orig(l)
        enddo
        iline_copy(0,k)=iline_copy(0,k)-1
      enddo

      nr=0  ! no dipoles found yet...

c Loop over all particles in the process
      do i=1,iline(0)
       do j=nincoming+1,iline(0) ! unresolved is always final state -> start do loop at nincoming+1
        do k=1,iline(0)
          if(i.ne.j .and. j.ne.k .and. i.ne.k) then !emitter, unresolved & spectator cannot be the same particle
c test if all of them are QED particles
         qed_part=0
         do l=1,20
          if(iline(i).eq.dipart(l))qed_part=qed_part+1
          if(iline(k).eq.dipart(l))qed_part=qed_part+1
          if(iline(j).eq.dipart(l))qed_part=qed_part+1
         enddo
          if(iline(j).eq.dipart(21))qed_part=qed_part+1
          if(iline(i).eq.dipart(21))qed_part=qed_part+1

c***********************************************************************************************
c If found that they are QED particles try testing if they can be defined as
c emitter, unresolved and spectator
c this fills the array info_ijk(a,b,c), where
c a) goes from 1 to nr, where nr is the total number of dipoles found
c b) goes from 1 to 2, where 1 denotes the particle as iline number,
c                      and 2 the particle as type (gluon or (anti-quark))
c c) goes from 1 to 5, denoting the 1: emitter
c                                   2: unresolved
c                                   3: spectator
c                                   4: emitter and unresolved combined (i.e. before branching)
c                                   5: spectator before branching
c***********************************************************************************************
         if(qed_part.eq.3) then
           do n=1,dum
            do l=-maxlines,maxlines
             iline(l)=iline_orig(l)   ! set process to the original process
            enddo
c    1. final-final
            if(i.gt. nincoming .and. j.gt. nincoming) then
c    1.1 combine final state q-qbar pair or lepton pair
             if(iline(i).eq.dipart(n).and.iline(j).eq.inverse(dipart(n)).and.
     &           iline(i).ne.dipart(21)) then
              nr=nr+1
              iline_copy(min(i,j),nr)=dipart(21)
              do l=max(i,j),iline(0)
               iline_copy(l,nr)=iline(l+1)
              enddo
              iline_copy(iline(0),nr)=0
              info_ijk(nr,1,1)=i          ! emitter
              info_ijk(nr,1,2)=j          ! unresolved
c              if(iline(i).eq.dipart(13)) then
c               info_ijk(nr,2,1)=0         ! emitter is gluon
c               info_ijk(nr,2,2)=0         ! unresolved is gluon
c              else
               info_ijk(nr,2,1)=1         ! emitter is quark (or anti-quark)
               info_ijk(nr,2,2)=1         ! unresolved is anti-quark (or quark)
c              endif
              info_ijk(nr,1,3)=k          ! spectator
              info_ijk(nr,1,4)=min(i,j)   ! emitter before branching
              info_ijk(nr,2,4)=0          ! emitter before branching is gluon
              if(k.gt.max(i,j)) then
               info_ijk(nr,1,5)=k-1       ! spectator before branching
              else
               info_ijk(nr,1,5)=k         ! spectator before branching
              endif
c              if(iline(k).eq.dipart(13)) then
c               info_ijk(nr,2,3)=0         ! spectator is gluon
c              else
c               info_ijk(nr,2,3)=1         ! spectator is (anti-)quark
c              endif
c              info_ijk(nr,2,5)=info_ijk(nr,2,3)  ! spectator does not change after branching
             endif
            endif
c    2.1 combine intial q/qbar or lepton with final state q/qbar or lepton
            if(i.le.nincoming .and. j.gt.nincoming) then
             if(iline(i).eq. dipart(n) .and. iline(j).eq.inverse(dipart(n))
     &          .and. iline(i).ne.dipart(21)) then
              nr=nr+1
              iline_copy(i,nr)=dipart(21)
              do l=j,iline(0)
               iline_copy(l,nr)=iline(l+1)
              enddo
              iline_copy(iline(0),nr)=0
              info_ijk(nr,1,1)=i          ! emitter
              info_ijk(nr,1,2)=j          ! unresolved
              info_ijk(nr,1,3)=k          ! spectator
              info_ijk(nr,1,4)=i          ! emitter before branching
              info_ijk(nr,2,1)=1          ! emitter is quark (or anti-quark)
              info_ijk(nr,2,2)=1          ! unresolved is anti-quark (or quark)
              info_ijk(nr,2,4)=0          ! emitter before branching is gluon
              if(k.gt.j) then
               info_ijk(nr,1,5)=k-1       ! spectator before branching
              else
               info_ijk(nr,1,5)=k         ! spectator before branching
              endif
              if(iline(k).eq.dipart(13)) then
               info_ijk(nr,2,3)=0         ! spectator is gluon
              else
               info_ijk(nr,2,3)=1         ! spectator is (anti-)quark
              endif
              info_ijk(nr,2,5)=info_ijk(nr,2,3)  ! spectator does not change after branching
             endif
            endif
           enddo   ! loop over n
c    2. combine final state photon with initial or final state parton
           if(j.gt.nincoming) then
            if(iline(j).eq.dipart(21).and.iline(i).ne.dipart(21)) then
             nr=nr+1
             do l=j,iline(0)
              iline_copy(l,nr)=iline(l+1)
             enddo
             iline_copy(iline(0),nr)=0
             info_ijk(nr,1,1)=i
             info_ijk(nr,1,2)=j
             info_ijk(nr,2,2)=0
             info_ijk(nr,1,3)=k
             if(j.gt.i) then
              info_ijk(nr,1,4)=i
             else
              info_ijk(nr,1,4)=i-1
             endif
             if(j.gt.k) then
              info_ijk(nr,1,5)=k
             else
              info_ijk(nr,1,5)=k-1
             endif
c             if(iline(i).eq.dipart(13)) then
c              info_ijk(nr,2,1)=0
c             else
              info_ijk(nr,2,1)=1
c             endif
c             if(iline(k).eq.dipart(13)) then
c              info_ijk(nr,2,3)=0
c             else
              info_ijk(nr,2,3)=1
c             endif
             if(info_ijk(nr,2,1).eq.0 ) then
              info_ijk(nr,2,4)=0
             else
              info_ijk(nr,2,4)=1
             endif
             info_ijk(nr,2,5)=info_ijk(nr,2,3)
            endif
           endif

c    2.2 combine initial photon with final quark/antiquark or lepton
           if(i.le.nincoming .and. j.gt.nincoming) then
            if(iline(i).eq.dipart(21).and.(iline(j).ne.dipart(21))) then
             nr=nr+1
             iline_copy(i,nr)=iline(j)
             do l=j,iline(0)
              iline_copy(l,nr)=iline(l+1)
             enddo
             iline_copy(iline(0),nr)=0
             info_ijk(nr,1,1)=i
             info_ijk(nr,1,2)=j
             info_ijk(nr,1,3)=k
             info_ijk(nr,1,4)=i
             info_ijk(nr,2,1)=0
             info_ijk(nr,2,2)=1
             info_ijk(nr,2,4)=1
             if(k.gt.j) then
              info_ijk(nr,1,5)=k-1
             else
              info_ijk(nr,1,5)=k
             endif
c             if(iline(k).eq.dipart(13)) then
c              info_ijk(nr,2,3)=0
c             else
c              info_ijk(nr,2,3)=1
c             endif
             info_ijk(nr,2,5)=info_ijk(nr,2,3)
            endif
           endif

          endif
         endif
        enddo
       enddo
      enddo
c  this terminates all the loops over the particles in the process.

      if (nr.gt.maxdipoles)then
         write (*,*) 'ERROR: FOUND TOO MANY DIPOLES', nr
         write (*,*) 'INCREASE MAXDIPOLES IN params.inc'
      endif


c Remove dipole if already generated before and update the iline_copy
      call removelines(iline_copy,nr)

      notfound=0
c loop over all dipoles
      dipol = 1
      do while (dipol .le. nr)
       print*,'ijk '
       print*,info_ijk(dipol,1,1),info_ijk(dipol,1,2),info_ijk(dipol,1,3),info_ijk(dipol,1,4),info_ijk(dipol,1,5)
       print*,info_ijk(dipol,2,1),info_ijk(dipol,2,2),info_ijk(dipol,2,3),info_ijk(dipol,2,4),info_ijk(dipol,2,5)


       nproc1=0
       graphnr=0
       more=.true.
c copy the dipole process over the original
       do l=0,iline(0)
        iline(l)=iline_copy(l,dipol)
       enddo
c    initialize flowinfo
         do l=1,max_particles
          flowinfo(l,1)=0
          flowinfo(l,2)=0
         enddo
       call getflowinfo1()
c       print*, 'flowinfo'
c       print*, flowinfo(1,1),flowinfo(1,2)
c       print*, flowinfo(2,1),flowinfo(2,2)
c       print*, flowinfo(3,1),flowinfo(3,2)
c       print*, flowinfo(4,1),flowinfo(4,2)
c       print*, flowinfo(5,1),flowinfo(5,2)
c       print*, flowinfo(6,1),flowinfo(6,2)
       open(unit=isubfile,file='subproc.txt',status='unknown')
       write(isubfile,'($a)') 'PROCESS = '
       open(unit=22,status='unknown')

c Get name for the dipol: 'dipolXXX', where the first three characters
c label the dipol
       iname=11
       ascii_nr=dipol+48
       ascii_emitter=info_ijk(dipol,1,4)+48
       ascii_spectator=info_ijk(dipol,1,5)+48
       if(dipol.le.9) then
          name='dipolqed'//char(48)//char(48)//char(ascii_nr)
       elseif(dipol.le.99) then
          name='dipolqed'//char(48)//char(dipol/10+48)
     &                //char(mod(dipol,10)+48) 
       elseif(dipol.le.999) then
          name='dipolqed'//char(dipol/100+48)
     &                //char((dipol-(dipol/100)*100)/10+48)
     &                //char(mod(dipol-(dipol/100)*100,10)+48)
       endif

c      do while (more)
       open(unit=91,status='scratch') ! here are the calls to HELAS temporarly stored
       flows(0,0,0,0)=0
       sumgluons=.true.
       sumgluons=.false.
       wcount=0
       print*,' '
       next=iline(0)
       if (lwrite) then
          open (unit=34,file='props.inc',status='unknown')
          open (unit=35,file='configs.inc',status='unknown')
          open (unit=36,file='decayBW.inc',status='unknown')
          open (unit=59,file='ngraphs.inc',status='unknown')
       else
          open (unit=34,status='scratch')
          open (unit=35,status='scratch')
          open (unit=36,status='scratch')
          open (unit=59,status='scratch')
       endif

       call InsertFields(tops,graphs)
       call write_config(tops,-99) !Close out 35
       if (lwrite) then
          close(35)
          close(36)
          close(34)
          close(59)
       else
          close(34,status='delete')
          close(35,status='delete')
          close(36,status='delete')
          close(59,status='delete')
       endif
c         print*,'here grpahs',graphs(0,0)
       if (graphs(0,0) .eq. 0) then
c          print*, 'No graphs for this process', (iline(i),i=1,iline(0))
          print*, 'No dipols found for this configuraton', (iline(i),i=1,iline(0))
          notfound=notfound+1
c     no graphs for this dipol config. -> remove it from the list
          do l=dipol,nr
             do k=-maxlines,maxlines
                iline_copy(k,l)=iline_copy(k,l+1)
             enddo
             do k=1,5
                info_ijk(l,1,k)=info_ijk(l+1,1,k)
                info_ijk(l,2,k)=info_ijk(l+1,2,k)
             enddo
          enddo
          nr=nr-1
       else
          print*,'There are ',graphs(0,0),' graphs.'
          graphcolor(0,0,0)=graphs(0,0) !Number of graphs
          print*,' '
          call saveproc(i,graphs(0,0))

c Set i=1, because otherwise we do not get all dipolXX.f files.
          i=1

c Do write the dipolXX.f files:
          lwrite=.true.
          if (i .gt. 0 .or. i .lt. -1) then !New Process 
             if (lwrite) then   !(i<0  means found matched process abs(i))
                lwrite=.false.
                first_proc = .false. !Now have processes
                call write_symmetry
                call gen_ps(graphs,tops,iline(0))
                call square(flows,sflows)
                open(unit=99,status='scratch') ! Here is the color info temporarly stored
                call matrixcolor(graphcolor,sflows)
                rewind 99       ! Rewind color info before writing in writeamp
                rewind 91       ! Rewind HELAS info before writing in writeamp
                call writeamp(graphs(0,0),next,
     $               goal_coup(2),goal_coup(1),i,flows)
                close(99,status='delete')
                do j=0,iline(0)
                   matchline(j)=iline(j)
                enddo
c Skip updating the leshouche file:
c                  open(unit=itnum,file='leshouche.inc',status='unknown')
c                  call write_leshouche(flows, itnum, i) !(color,ilun,iproc)
c                  close(itnum)
c Do not add lines to minput.mg, because it should be generated by normal MG run
c               else
c                  open(unit=itnum,file='minput.mg',status='unknown',
c     &                 access='append')
c                  call write_proc(itnum)
c                  close(itnum)
             endif
c Skip updating the leshouche file:
c            elseif (i .eq. -1)     then !Found Match
c               call genparton2()   !Write out pdf's 
cc               write(*,*) 'Writing genparton2',i
c               open(unit=itnum,file='leshouche.inc',status='unknown',
c     &              access='append')
c               call write_leshouche(flows, itnum, i) !(color,ilun,iproc)
c               close(itnum)
          endif
c Do not update minput.mg
c            if (cross_opt) then   
c               open(unit=itnum,file='minput.mg',status='unknown',
c     &              access='append')
c               call write_cross(itnum)
c               close(itnum)
c            endif
          close(91,status='delete')
          dipol = dipol+1
       endif
       close(35)
c         call resetV
       write(*,*) 
       write(*,*) 

c Do not do anything here for the dipolterms. If no dipols can be found, just
c skip the subprocess
c         if (jetloop .or. lwrite) then
c            call readproc(more)
c         else          !Only interested in processes that can match
c            open(unit=itnum,file='minput.mg',status='unknown',
c     &        access='append')
c            lpossible = .false.
c            do while (more .and. .not. lpossible) 
cc               call readproc(more)
c               if (more) then
c                  lpossible = qmatch_check(iline(0))
c                  if (.not. lpossible) then
c                     call write_proc(itnum)
c                  endif
c               endif
c            enddo
c            close(itnum)
c         endif
               
c      enddo

       close(unit=isubfile)
c Not needed to write info in minput.mg file.
c      if (.not. lwrite) then
c         open(unit=itnum,file='minput.mg',status='unknown',
c     &        access='append')
cc         write(itnum,*)' '
c         write(itnum,*) 'done'
c         close(itnum)
c      endif

      enddo    !loop over dipoles (nr)

c Write auto_dsig.f
       rewind 22
       call writedsig(iline(0),22,.false.)
       close(22,status='delete')
      write(*,*)
      write(*,*)
      write(*,*) 'Thank you for using MadGraph'
      write(*,*)
      
!************* These are for color flow information only ******************
!      call writecolor(graphcolor,sflows,goodflow)
!      call writeflows(flows,goodflow)

      end



      subroutine square(flows,sflows)
!**************************************************************************
!     Square terms and simplify to get color factors for flows
!**************************************************************************
      implicit none

! Constants

      include 'params.inc'
c      integer    maxlines,  maxfactors,  maxterms,    maxflows
c      parameter (maxlines=8,maxfactors=9,maxterms=250,maxflows=200)

! Arguments

      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      double precision  sflows(maxflows,maxflows)

! Local Variables

      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer nflows,nfactors,nelements
      integer iflow,ifact,ielement,iterm,cterm,fterm
      integer cflow,cfact,cfactors
      integer i,j
      double precision sdiag
      
! Global Variables

      integer           isflows(2,maxflows,maxflows)
      common/to_isflow/isflows
      logical         sumgluons
      common/to_cflow/sumgluons
!-----------
! Begin Code
!-----------
      nflows=flows(0,0,0,0)
      sumgluons=.true.
      do iflow=1,nflows
c         write(*,*) 'Flow number ',iflow
c         call PrintColors(flows(0,0,0,iflow))
         call SimpColors(flows(0,0,0,iflow),-1)  !Sum over internal gluon
c         call PrintColors(flows(0,0,0,iflow))
      enddo
      do iflow=1,nflows
         do cflow=iflow,nflows
            do iterm=1,flows(0,0,0,iflow)
               nfactors=flows(0,0,iterm,iflow)
               do ifact=0,nfactors
                  nelements=abs(flows(0,ifact,iterm,iflow))
                  do ielement=0,nelements
                     color(ielement,ifact,iterm)=
     &                    flows(ielement,ifact,iterm,iflow)
                  enddo
               enddo
            enddo                    !have all terms copied
            color(0,0,0)=flows(0,0,0,iflow)    !This is number of terms
            do cterm=2,flows(0,0,0,cflow)
               do iterm=1,flows(0,0,0,iflow)
                  call copyterm(color,iterm,-999,-999)
               enddo
            enddo              !now we have enough set for all square terms
            do cterm=1,flows(0,0,0,cflow)
               cfactors=flows(0,0,cterm,cflow)
               do iterm=1,flows(0,0,0,iflow)
                  nfactors=flows(0,0,iterm,iflow)
                  fterm = flows(0,0,0,iflow)*(cterm-1)+iterm
                  color(0,0,fterm) = nfactors+cfactors-1
                  color(0,1,fterm) = 2 !num and denom
                  color(1,1,fterm) = color(1,1,fterm)*
     &                 flows(1,1,cterm,cflow)
                  color(2,1,fterm) = color(2,1,fterm)*
     &                 flows(2,1,cterm,cflow)
                  do cfact=2,cfactors
                     nelements=abs(flows(0,cfact,cterm,cflow))
                     color(0,nfactors+cfact-1,fterm)=
     &                    flows(0,cfact,cterm,cflow)
                     if (flows(0,cfact,cterm,cflow) .lt. 0) then !T Matrix
                        color(1,cfact+nfactors-1,fterm) =
     &                       flows(2,cfact,cterm,cflow)
                        color(2,cfact+nfactors-1,fterm) =
     &                          flows(1,cfact,cterm,cflow)
                        do ielement=3,nelements
                           color(ielement,cfact+nfactors-1,fterm)=
     &                          flows(nelements-ielement+3,cfact,
     &                          cterm,cflow)
                        enddo
                     else
                        do ielement=1,nelements
                           color(ielement,cfact+nfactors-1,fterm)=
     &                          flows(nelements-ielement+1,cfact,
     &                          cterm,cflow)
                        enddo
                     endif
                  enddo
               enddo
            enddo
            call simpcolors(color,1)
            call addterms(color)
            if (color(0,0,0) .ge. 1) then
               isflows(1,iflow,cflow)=color(1,1,1)
               isflows(2,iflow,cflow)=color(2,1,1)
               isflows(1,cflow,iflow)=color(1,1,1)
               isflows(2,cflow,iflow)=color(2,1,1)
               sflows(iflow,cflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               sflows(cflow,iflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               if (color(0,0,0) .gt. 1) then
                  print*,'Error More than one term',color(0,0,1)
                  call printcolors(color)
               elseif (color(0,0,1) .gt. 1) then !one factor
                  print*,'One term but many factors',color(0,0,1),
     &                 iflow,cflow,color(1,1,1)
                  call printcolors(color)
               endif
            else
               sflows(iflow,cflow)=0.d0
               sflows(cflow,iflow)=0.d0
            endif
c            if (iflow .eq. cflow .and. sflows(iflow,cflow) .lt. 0) then
c               write(*,'(2i4,f21.15)') iflow,cflow,sflows(iflow,cflow)
c               write(*,'(4i4)') color(1,1,1),color(2,1,1)
c            endif
         enddo
      enddo
c
c     Surprisingly diagonal elements aren't always biggest because
c     of extra terms which subtract. So don't use this check anymore
c
c      do i=1,nflows
c         sdiag = abs(sflows(i,i))
c         do j=1,nflows
c            if (abs(sflows(j,i)) .gt. sdiag) then
c               write(*,'(a,2i4,2f20.5)') 'Warning diag not largest',j,i,
c     &              sflows(j,i)/sdiag, sdiag
c               write(*,'(a,2i4,1f10.5,2i20)') 'Warning',j,i,
c     &              sflows(j,i)/sdiag, isflows(1,j,i),isflows(2,j,i)
c
c            endif
c         enddo
c      enddo
      end
