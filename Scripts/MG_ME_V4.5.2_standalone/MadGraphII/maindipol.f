      Program Dipolterms

      implicit none

      include 'params.inc'
c     Global
      integer info_ijk(maxdipoles,2,5),nr
      common /ijk/ info_ijk,nr

      call madgraph

      call write_dipols()
      call write_intdipoles()

      end






      Subroutine MADGRAPH()
!*************************************************************************
!     Main program for MadGraph
!*************************************************************************
      implicit none

! Constants

      include 'params.inc'


! Local Variables

      integer tops(0:4,0:maxnodes,0:maxtops)
      integer graphs(0:maxgraphs,0:maxlines) !graphs, topology internal lines
      integer next,i,ntopold,ii,j,idipol,i1
      double precision sflows(maxflows,maxflows)
      logical more, lpossible,foundborn,foundin,foundfi
      integer fortran,ascii_emitter,ascii_spectator,ascii_n,ascii_nr
      integer dum,m,dipart(2*maxlines),n,k,l,dum1,qcd_part,notfound
      character*70 buff
      integer ipart(maxlines),step(maxlines),jhel,initc

! External Functions
      logical qmatch_check

! Global Variables

      integer        iline(-maxlines:maxlines),idir(-maxlines:maxlines)
      integer        this_coup(max_coup) ,goal_coup(max_coup)
      common/to_proc/iline,idir,this_coup,goal_coup
      integer         nincoming,nincfirst
      common/to_proc2/nincoming,nincfirst

      integer iline_copy(-maxlines:maxlines,maxdipoles)
      common /to_writedipole/iline_copy

      character*25        name
      integer        iname
      common/to_name/iname,name
      integer alen(maxgraphs)
      integer wnum(-maxlines:maxlines),wcount,wlen(maxgraphs*maxlines)
      common/toopt/wcount,wnum,wlen,alen
      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      integer         graphcolor(0:2,0:maxflows,0:maxgraphs)
      common/to_color/graphcolor,flows
      character*(4*max_particles) particle(4)
      integer                               charge_c(max_particles)
      integer iparticle(0:max_particles,0:4),inverse(max_particles)
      common/to_model/iparticle,  particle,  inverse, charge_c

      logical          this_block(0:max_blocks), need_block(max_blocks)
      common/to_blocks/this_block              , need_block

      logical         sumgluons
      common/to_cflow/sumgluons

      logical              lwrite
      common/to_multiproc/ lwrite

      logical           jetloop
      common/to_jetloop/jetloop

      integer          matchline(0:maxlines)
      common/to_qmatch/matchline

      logical              cross_opt
      common /to_crossopt/ cross_opt

      character*70       cversion
      common/to_version/ cversion
      character*(40)       particleID, interactionID
      common/to_modelinput/particleID, interactionID

      logical             first_proc
      common/to_firstproc/first_proc

      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),maxigraphs,max_ifactor(maxterms)
      integer graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr

      integer dipollist(maxdipoles,2,2),nrdipols
      common /list/ dipollist,nrdipols

      character*60 proc
      integer iproc
      common/to_write/iproc,proc

      integer info_ijk(maxdipoles,2,5),nr,dipol
      common /ijk/ info_ijk,nr
      common /dipolenumber/dipol

      integer iline_orig(-maxlines:maxlines)
      common /ciline_orig/iline_orig

      integer flowinfo(max_particles,2)
      common /flow_info/ flowinfo

      integer wcount1(maxproc),acount1(maxproc)
      integer wlen1(maxgraphs*maxlines,maxproc)
      integer alen1(maxgraphs,maxproc),nproc1
      common/toglobal/wcount1,acount1,wlen1,alen1,nproc1

      integer isymn1
      common /isym/ isymn1

      integer info_p(5,max_particles),iposx(3,max_particles)
      character*(max_string) iwave(max_particles),owave(max_particles)
      character*(8) str(3,max_particles)
      common/to_external/iwave,owave,iposx,info_p,str

      character*(8) mass(max_particles)
      common /masses/ mass
! Data Table

! If you want the output function written using real*8 and complex*16
! style declarations, remove the comment character from the following
! line.

      data fortran /77/
      data interactionid /"???"/
      data particleid /"???"/

!-----------
! Begin Code
!-----------
c      open (unit=6, file='output.dat',status='unknown')
      cversion='Generated by MadGraph II'

      first_proc = .true.
      ntopold=0
c do not write extra files, only the dipol1234.f:
       lwrite=.false.
      call resetV
      call Load_Particles
      call Load_Interactions
      print*,' '
c      call writelogo
      print*,' '
      
 10   call readproc(more)

      do i=1,iline(0)
       mass(i)=str(2,iline(i))
      enddo


c calculating the symmetry factor of the n+1 process
      do i=1,maxlines
       ipart(i)=i
      enddo
      call getdenom(isymn1,initc,jhel,step,ipart)

c copy the process to to iline_orig
      do k=-maxlines,maxlines
       iline_orig(k)=iline(k)
      enddo

     
      i1 = index(proc,'>')
c get all QCD particles (do not change the order!)
      call getparticle('u u~ d d~ s s~ c c~ b b~ t t~ g',dipart,dum)

c copy the original process in which we can start combining particles to dipoles
      do k=1,maxdipoles
        do l=-maxlines,maxlines
          iline_copy(l,k)=iline_orig(l)
        enddo
        iline_copy(0,k)=iline_copy(0,k)-1
      enddo

      nr=0  ! no dipoles found yet...

c Loop over all particles in the process
      do i=1,iline(0)
       do j=nincoming+1,iline(0) ! unresolved is always final state -> start do loop at nincoming+1
        do k=1,iline(0)
          if(i.ne.j .and. j.ne.k .and. i.ne.k) then !emitter, unresolved & spectator cannot be the same particle
c test if all of them are QCD particles
         qcd_part=0
         do l=1,13
          if(iline(i).eq.dipart(l))qcd_part=qcd_part+1
          if(iline(j).eq.dipart(l))qcd_part=qcd_part+1
          if(iline(k).eq.dipart(l))qcd_part=qcd_part+1
         enddo
c***********************************************************************************************
c If found that they are QCD particles try testing if they can be defined as
c emitter, unresolved and spectator
c this fills the array info_ijk(a,b,c), where
c a) goes from 1 to nr, where nr is the total number of dipoles found
c b) goes from 1 to 2, where 1 denotes the particle as iline number,
c                      and 2 the particle as type (gluon or (anti-quark))
c c) goes from 1 to 5, denoting the 1: emitter
c                                   2: unresolved
c                                   3: spectator
c                                   4: emitter and unresolved combined (i.e. before branching)
c                                   5: spectator before branching
c***********************************************************************************************
         if(qcd_part.eq.3) then
           do n=1,dum
            do l=-maxlines,maxlines
             iline(l)=iline_orig(l)   ! set process to the original process
            enddo
c    1. final-final
            if(i.gt. nincoming .and. j.gt. nincoming) then
c    1.1 combine final state q-qbar pair or g-g pair
             if(iline(i).eq.dipart(n).and.iline(j).eq.inverse(dipart(n))) then
              nr=nr+1
              iline_copy(min(i,j),nr)=dipart(13)
c              do l=min(i,j)+1,iline(0)
              do l=max(i,j),iline(0)
               iline_copy(l,nr)=iline(l+1)
              enddo
              iline_copy(iline(0),nr)=0
              info_ijk(nr,1,1)=i          ! emitter
              info_ijk(nr,1,2)=j          ! unresolved
              if(iline(i).eq.dipart(13)) then
               info_ijk(nr,2,1)=0         ! emitter is gluon
               info_ijk(nr,2,2)=0         ! unresolved is gluon
              else
               info_ijk(nr,2,1)=1         ! emitter is quark (or anti-quark)
               info_ijk(nr,2,2)=1         ! unresolved is anti-quark (or quark)
              endif
              info_ijk(nr,1,3)=k          ! spectator
              info_ijk(nr,1,4)=min(i,j)   ! emitter before branching
              info_ijk(nr,2,4)=0          ! emitter before branching is gluon
              if(k.gt.max(i,j)) then
               info_ijk(nr,1,5)=k-1       ! spectator before branching
              else
               info_ijk(nr,1,5)=k         ! spectator before branching
              endif
              if(iline(k).eq.dipart(13)) then
               info_ijk(nr,2,3)=0         ! spectator is gluon
              else
               info_ijk(nr,2,3)=1         ! spectator is (anti-)quark
              endif
              info_ijk(nr,2,5)=info_ijk(nr,2,3)  ! spectator does not change after branching
             endif
            endif
c    2.1 combine intial q/qbar with final state q/qbar 
            if(i.le.nincoming .and. j.gt.nincoming) then
             if(iline(i).eq. dipart(n) .and. iline(j).eq.inverse(dipart(n))
     &          .and. iline(i).ne.dipart(13)) then
              nr=nr+1
              iline_copy(i,nr)=dipart(13)
              do l=j,iline(0)
               iline_copy(l,nr)=iline(l+1)
              enddo
              iline_copy(iline(0),nr)=0
              info_ijk(nr,1,1)=i          ! emitter
              info_ijk(nr,1,2)=j          ! unresolved
              info_ijk(nr,1,3)=k          ! spectator
              info_ijk(nr,1,4)=i          ! emitter before branching
              info_ijk(nr,2,1)=1          ! emitter is quark (or anti-quark)
              info_ijk(nr,2,2)=1          ! unresolved is anti-quark (or quark)
              info_ijk(nr,2,4)=0          ! emitter before branching is gluon
              if(k.gt.j) then
               info_ijk(nr,1,5)=k-1       ! spectator before branching
              else
               info_ijk(nr,1,5)=k         ! spectator before branching
              endif
              if(iline(k).eq.dipart(13)) then
               info_ijk(nr,2,3)=0         ! spectator is gluon
              else
               info_ijk(nr,2,3)=1         ! spectator is (anti-)quark
              endif
              info_ijk(nr,2,5)=info_ijk(nr,2,3)  ! spectator does not change after branching
             endif
            endif
           enddo   ! loop over n
c    2. combine final state gluon with initial or final state parton
           if(j.gt.nincoming) then
            if(iline(j).eq.dipart(13)) then
             nr=nr+1
             do l=j,iline(0)
              iline_copy(l,nr)=iline(l+1)
             enddo
             iline_copy(iline(0),nr)=0
             info_ijk(nr,1,1)=i
             info_ijk(nr,1,2)=j
             info_ijk(nr,2,2)=0
             info_ijk(nr,1,3)=k
             if(j.gt.i) then
              info_ijk(nr,1,4)=i
             else
              info_ijk(nr,1,4)=i-1
             endif
             if(j.gt.k) then
              info_ijk(nr,1,5)=k
             else
              info_ijk(nr,1,5)=k-1
             endif
             if(iline(i).eq.dipart(13)) then
              info_ijk(nr,2,1)=0
             else
              info_ijk(nr,2,1)=1
             endif
             if(iline(k).eq.dipart(13)) then
              info_ijk(nr,2,3)=0
             else
              info_ijk(nr,2,3)=1
             endif
             if(info_ijk(nr,2,1).eq.0 ) then
              info_ijk(nr,2,4)=0
             else
              info_ijk(nr,2,4)=1
             endif
             info_ijk(nr,2,5)=info_ijk(nr,2,3)
            endif
           endif

c    2.2 combine initial gluon with final quark/antiquark
           if(i.le.nincoming .and. j.gt.nincoming) then
            if(iline(i).eq.dipart(13).and.iline(j).ne.dipart(13)) then
             nr=nr+1
             iline_copy(i,nr)=iline(j)
             do l=j,iline(0)
              iline_copy(l,nr)=iline(l+1)
             enddo
             iline_copy(iline(0),nr)=0
             info_ijk(nr,1,1)=i
             info_ijk(nr,1,2)=j
             info_ijk(nr,1,3)=k
             info_ijk(nr,1,4)=i
             info_ijk(nr,2,1)=0
             info_ijk(nr,2,2)=1
             info_ijk(nr,2,4)=1
             if(k.gt.j) then
              info_ijk(nr,1,5)=k-1
             else
              info_ijk(nr,1,5)=k
             endif
             if(iline(k).eq.dipart(13)) then
              info_ijk(nr,2,3)=0
             else
              info_ijk(nr,2,3)=1
             endif
             info_ijk(nr,2,5)=info_ijk(nr,2,3)
            endif
           endif

          endif
         endif
        enddo
       enddo
      enddo
c  this terminates all the loops over the particles in the process.

      if (nr.gt.maxdipoles)then
         write (*,*) 'ERROR: FOUND TOO MANY DIPOLES', nr
         write (*,*) 'INCREASE MAXDIPOLES IN params.inc'
      endif


c Remove dipole if already generated before and update the iline_copy
      call removelines(iline_copy,nr)

      notfound=0
c loop over all dipoles
      dipol = 1
      do while (dipol .le. nr)
       print*,'ijk '
       print*,info_ijk(dipol,1,1),info_ijk(dipol,1,2),info_ijk(dipol,1,3),info_ijk(dipol,1,4),info_ijk(dipol,1,5)
       print*,info_ijk(dipol,2,1),info_ijk(dipol,2,2),info_ijk(dipol,2,3),info_ijk(dipol,2,4),info_ijk(dipol,2,5)
       nproc1=0
       graphnr=0
       more=.true.
c copy the dipole process over the original
       do l=0,iline(0)
        iline(l)=iline_copy(l,dipol)
       enddo
c    initialize flowinfo
         do l=1,max_particles
          flowinfo(l,1)=0
          flowinfo(l,2)=0
         enddo
       call getflowinfo1()
       open(unit=isubfile,file='subproc.txt',status='unknown')
       write(isubfile,'($a)') 'PROCESS = '
       open(unit=22,status='unknown')

c Get name for the dipol: 'dipolXXX', where the last three characters
c label the dipol
       iname=8
       ascii_nr=dipol+48
       ascii_emitter=info_ijk(dipol,1,4)+48
       ascii_spectator=info_ijk(dipol,1,5)+48
       if(dipol.le.9) then
          name='dipol'//char(48)//char(48)//char(ascii_nr)
       elseif(dipol.le.99) then
          name='dipol'//char(48)//char(dipol/10+48)
     &                //char(mod(dipol,10)+48) 
       elseif(dipol.le.999) then
          name='dipol'//char(dipol/100+48)
     &                //char((dipol-(dipol/100)*100)/10+48)
     &                //char(mod(dipol-(dipol/100)*100,10)+48)
       endif

c      do while (more)
       open(unit=91,status='scratch') ! here are the calls to HELAS temporarly stored
       flows(0,0,0,0)=0
       sumgluons=.true.
       sumgluons=.false.
       wcount=0
       print*,' '
       next=iline(0)
       if (lwrite) then
          open (unit=34,file='props.inc',status='unknown')
          open (unit=35,file='configs.inc',status='unknown')
          open (unit=36,file='decayBW.inc',status='unknown')
          open (unit=59,file='ngraphs.inc',status='unknown')
       else
          open (unit=34,status='scratch')
          open (unit=35,status='scratch')
          open (unit=36,status='scratch')
          open (unit=59,status='scratch')
       endif

       call InsertFields(tops,graphs)
       call write_config(tops,-99) !Close out 35
       if (lwrite) then
          close(35)
          close(36)
          close(34)
          close(59)
       else
          close(34,status='delete')
          close(35,status='delete')
          close(36,status='delete')
          close(59,status='delete')
       endif
c         print*,'here grpahs',graphs(0,0)
       if (graphs(0,0) .eq. 0) then
c          print*, 'No graphs for this process', (iline(i),i=1,iline(0))
          print*, 'No dipols found for this configuraton', (iline(i),i=1,iline(0))
          notfound=notfound+1
c     no graphs for this dipol config. -> remove it from the list
          do l=dipol,nr
             do k=-maxlines,maxlines
                iline_copy(k,l)=iline_copy(k,l+1)
             enddo
             do k=1,5
                info_ijk(l,1,k)=info_ijk(l+1,1,k)
                info_ijk(l,2,k)=info_ijk(l+1,2,k)
             enddo
          enddo
          nr=nr-1
       else
          print*,'There are ',graphs(0,0),' graphs.'
          graphcolor(0,0,0)=graphs(0,0) !Number of graphs
          print*,' '
          call saveproc(i,graphs(0,0))

c Set i=1, because otherwise we do not get all dipolXX.f files.
          i=1

c Do write the dipolXX.f files:
          lwrite=.true.
          if (i .gt. 0 .or. i .lt. -1) then !New Process 
             if (lwrite) then   !(i<0  means found matched process abs(i))
                lwrite=.false.
                first_proc = .false. !Now have processes
                call write_symmetry
                call gen_ps(graphs,tops,iline(0))
                call square(flows,sflows,info_ijk(dipol,1,4),info_ijk(dipol,1,5))
                open(unit=99,status='scratch') ! Here is the color info temporarly stored
                call matrixcolor(graphcolor,sflows)
                rewind 99       ! Rewind color info before writing in writeamp
                rewind 91       ! Rewind HELAS info before writing in writeamp
                call writeamp(graphs(0,0),next,
     $               goal_coup(2),goal_coup(1),i,flows)
                close(99,status='delete')
                do j=0,iline(0)
                   matchline(j)=iline(j)
                enddo
             endif
          endif
          close(91,status='delete')
          dipol = dipol+1
       endif
       close(35)
       write(*,*) 
       write(*,*) 

       close(unit=isubfile)

      enddo    !loop over dipoles (nr)

c Write auto_dsig.f
       rewind 22
       call writedsig(iline(0),22,.false.)
       close(22,status='delete')

      write(*,*)
      write(*,*)
      write(*,*) 'Thank you for using MadGraph'
      write(*,*)
      
!************* These are for color flow information only ******************
!      call writecolor(graphcolor,sflows,goodflow)
!      call writeflows(flows,goodflow)

      end





      subroutine square(flows,sflows,emitter,spectator)
!**************************************************************************
!     Square terms and simplify to get color factors for flows
!**************************************************************************
      implicit none

! Constants

      include 'params.inc'
c      integer    maxlines,  maxfactors,  maxterms,    maxflows
c      parameter (maxlines=8,maxfactors=9,maxterms=250,maxflows=200)

! Arguments

      integer flows(0:2*maxlines,0:maxfactors,0:24,0:maxflows)
      double precision  sflows(maxflows,maxflows)
      integer emitter,spectator

! Local Variables

      integer color(0:2*maxlines,0:maxfactors,0:maxterms)
      integer nflows,nfactors,nelements
      integer iflow,ifact,ielement,iterm,cterm,fterm
      integer cflow,cfact,cfactors
      integer i,j
      double precision sdiag
      integer sqcolor(0:2*maxlines,0:maxfactors,0:maxterms)
      
! Global Variables

      integer           isflows(2,maxflows,maxflows)
      common/to_isflow/isflows
      logical         sumgluons
      common/to_cflow/sumgluons

      integer color_tot(2,200,0:2*maxlines,0:maxfactors,0:maxterms),maxigraphs,max_ifactor(maxterms),graphnr
      common /dipol/ color_tot,maxigraphs,max_ifactor,graphnr
!-----------
! Begin Code
!-----------
      nflows=flows(0,0,0,0)
      sumgluons=.true.
      do iflow=1,nflows
c         write(*,*) 'Flow number ',iflow
c         call PrintColors(flows(0,0,0,iflow))
         call SimpColors(flows(0,0,0,iflow),-1)  !Sum over internal gluon
       
c         call PrintColors(flows(0,0,0,iflow))
      enddo
      do iflow=1,nflows
         do cflow=iflow,nflows
            do iterm=1,flows(0,0,0,iflow)
               nfactors=flows(0,0,iterm,iflow)
               do ifact=0,nfactors
                  nelements=abs(flows(0,ifact,iterm,iflow))
                  do ielement=0,nelements
                     color(ielement,ifact,iterm)=
     &                    flows(ielement,ifact,iterm,iflow)
                  enddo
               enddo
            enddo                    !have all terms copied
            color(0,0,0)=flows(0,0,0,iflow)    !This is number of terms
           call storecolor(color,iflow)
      enddo
      enddo
      call clearzeros(color)
      call insertdipol(color,emitter,spectator)
      call doublecolor_tot(color,emitter,spectator)
      do iflow=1,nflows
         do cflow=iflow,nflows
             isflows(1,iflow,cflow)=0
             isflows(2,iflow,cflow)=0
             isflows(1,cflow,iflow)=0
             isflows(2,cflow,iflow)=0
             call squarecolor_tot(color,color_tot,sqcolor,iflow,cflow,max_ifactor,emitter,spectator)
             call dipolcolormatrix(sqcolor,color,iflow,cflow,emitter,spectator)
            if (color(0,0,0) .ge. 1) then
               isflows(1,iflow,cflow)=color(1,1,1)
               isflows(2,iflow,cflow)=color(2,1,1)
               isflows(1,cflow,iflow)=color(1,1,1)
               isflows(2,cflow,iflow)=color(2,1,1)
               sflows(iflow,cflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               sflows(cflow,iflow)=dble(color(1,1,1))/
     &              dble(color(2,1,1))
               if (color(0,0,0) .gt. 1) then
                  print*,'Error More than one term',color(0,0,1)
                  call printcolors(color)
               elseif (color(0,0,1) .gt. 1) then !one factor
                  print*,'One term but many factors',color(0,0,1),
     &                 iflow,cflow,color(1,1,1)
                  call printcolors(color)
               endif
            else
c               print*,'wenn color=0',iflow,cflow
               isflows(1,iflow,cflow)=0
               isflows(2,iflow,cflow)=0
c               print*, isflows(1,1,1),isflows(2,1,1)
               sflows(iflow,cflow)=0.d0
               sflows(cflow,iflow)=0.d0
            endif
         enddo
      enddo
      end
